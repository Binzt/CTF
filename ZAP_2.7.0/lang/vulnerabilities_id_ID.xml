<?xml version="1.0" encoding="utf-8" ?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Tidak memadai otentikasi</alert>
	<desc>Tidak memadai otentikasi terjadi bila situs web memungkinkan seorang penyerang untuk mengakses konten yang sensitif atau fungsi tanpa harus mengotentikasi dengan benar. Administrasi berbasis web alat adalah contoh yang baik dari situs web yang menyediakan akses ke fungsionalitas sensitif. Tergantung pada sumber online tertentu, aplikasi web ini tidak boleh langsung dapat diakses tanpa memerlukan pengguna untuk benar memverifikasi identitas mereka.

Untuk menyiapkan otentikasi, beberapa sumber daya yang dilindungi oleh "bersembunyi" lokasi tertentu dan tidak menghubungkan lokasi ke situs web utama atau tempat umum lainnya. Namun, pendekatan ini adalah tidak lebih daripada "Keamanan melalui ketidakjelasan". Hal ini penting untuk memahami bahwa meskipun sumber daya yang tidak diketahui oleh seorang penyerang, itu masih dapat diakses langsung melalui URL tertentu. URL tertentu dapat ditemukan melalui kekerasan menyelidik untuk file Umum dan lokasi direktori (/ admin misalnya), pesan kesalahan, log Referer atau dokumentasi seperti file bantuan. Sumber ini, apakah mereka adalah konten - atau fungsi-driven, harus cukup dilindungi.</desc>
	<solution>Tahap: Arsitektur dan desain menggunakan kerangka otentikasi atau perpustakaan seperti fitur OWASP ESAPI otentikasi.</solution>
	<reference>http://projects.webappsec.org/insufficient-transport-layer-protection</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Tidak cukup otorisasi</alert>
	<desc>Cukup otorisasi hasil ketika sebuah aplikasi tidak melakukan otorisasi memadai cek untuk memastikan bahwa pengguna melakukan fungsi atau mengakses data sesuai dengan kebijakan keamanan. Otorisasi prosedur harus menegakkan apa pengguna, Layanan atau aplikasi diizinkan untuk melakukan. Ketika pengguna diotentikasi ke situs web, itu tidak berarti bahwa pengguna harus memiliki akses penuh ke semua isi dan fungsi.

Kurangnya fungsi banyak otorisasi aplikasi memberikan fungsionalitas aplikasi yang berbeda untuk pengguna yang berbeda. Situs berita akan memungkinkan pengguna untuk melihat berita, namun tidak mempublikasikan mereka. Sistem akuntansi akan memiliki hak akses yang berbeda untuk petugas pengeluaran kas dan piutang petugas. Kurangnya fungsi otorisasi terjadi ketika sebuah aplikasi tidak mencegah pengguna dari mengakses fungsi aplikasi melanggar kebijakan keamanan.

Sebuah contoh yang sangat terlihat adalah hack 2005 dari proses aplikasi di Harvard Business School. Kegagalan otorisasi yang memungkinkan pengguna untuk melihat data mereka sendiri ketika mereka seharusnya tidak diizinkan untuk mengakses bagian dari situs web.
 
Kurangnya Data banyak otorisasi aplikasi mengekspos pengidentifikasi data dasar di URL. Misalnya, saat mengakses rekam medis pada sistem seseorang mungkin memiliki URL seperti:

http://example.com/RecordView?id=12345

Jika aplikasi tidak memeriksa apakah ID pengguna yang diotentikasi telah membaca hak, maka ia dapat menampilkan data ke pengguna yang tidak boleh dilihat pengguna.

Otorisasi Data yang Tidak Cukup lebih sering terjadi daripada Otorisasi Fungsi Tidak Cukup karena pemrogram umumnya memiliki pengetahuan lengkap tentang fungsionalitas aplikasi, namun tidak selalu memiliki pemetaan lengkap semua data yang akan diakses aplikasi. Pemrogram sering memiliki kontrol ketat atas mekanisme otorisasi fungsi, namun mengandalkan sistem lain seperti database untuk melakukan otorisasi data.</desc>
	<solution>Fase: Arsitektur dan desain; Operasi ini sangat hati-hati mengelola pengaturan, manajemen, dan penanganan hak istimewa. Secara eksplisit mengelola zona kepercayaan dalam perangkat lunak.

Tahap: Arsitektur dan Desain
Pastikan kompartementalisasi yang sesuai dibangun ke dalam perancangan sistem dan kompartementalisasi berfungsi untuk memungkinkan dan memperkuat fungsi pemisahan hak istimewa. Arsitek dan desainer harus bergantung pada prinsip yang paling tidak istimewa untuk memutuskan kapan sebaiknya menggunakan dan menjatuhkan hak istimewa sistem.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Integer Overflows</alert>
	<desc>Integer Overflow adalah kondisi yang terjadi ketika hasil dari operasi aritmetika, seperti perkalian atau penambahan, melebihi ukuran maksimum tipe integer yang digunakan untuk menyimpannya. Ketika terjadi suatu overflow integer, nilai ditafsirkan akan muncul untuk memiliki "dibungkus di sekitar" nilai maksimum dan mulai lagi di nilai minimum, mirip dengan sebuah jam yang mewakili 13:00 dengan menunjuk pada 1:00.

Sebagai contoh, 8-bit integer ditandatangani pada arsitektur komputer yang paling umum memiliki nilai maksimum 127 dan nilai minimal-128. Jika seorang programmer menyimpan nilai 127 di sebuah variabel dan menambah 1 itu, hasilnya harus menjadi 128. Namun, nilai ini melebihi maksimum untuk tipe integer, sehingga nilai ditafsirkan akan "membungkus" dan menjadi-128.</desc>
	<solution>Tahap: Persyaratan pastikan bahwa semua protokol yang ketat didefinisikan, sehingga semua out-of-bounds perilaku dapat diidentifikasi hanya, dan memerlukan ketat kesesuaian protokol.

Tahap: Arsitektur dan Desain
Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.
Jika mungkin, memilih bahasa atau compiler yang melakukan otomatis batas memeriksa.

Tahap: Arsitektur dan Desain
Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.
Gunakan perpustakaan atau kerangka kerja yang memudahkan menangani angka tanpa konsekuensi tak terduga.
Contohnya termasuk paket penanganan bilangan bulat yang aman seperti SafeInt (C++) atau IntegerLib (C atau C++).

Tahap: Implementasi melakukan validasi input pada angka setiap input dengan memastikan bahwa itu adalah dalam kisaran diharapkan. Menegakkan bahwa input memenuhi kedua persyaratan minimum dan maksimum untuk kisaran diharapkan.
Gunakan unsigned integer mana mungkin. Hal ini membuat lebih mudah untuk melakukan kewarasan cek untuk integer meluap. Jika Anda harus menggunakan bilangan bulat ditandatangani, pastikan bahwa cek jangkauan Anda termasuk nilai-nilai minimum serta nilai maksimum.

Tahap: Implementasi memahami bahasa pemrograman Anda mendasari representasi dan bagaimana berinteraksi dengan perhitungan numerik (CWE-681). Perhatikan perbedaan ukuran byte, presisi, perbedaan ditandatangani/unsigned, pemotongan, konversi dan pengecoran antara jenis, "tidak-a-nomor" perhitungan dan bagaimana bahasa Anda menangani angka-angka yang terlalu besar atau terlalu kecil untuk yang mendasari representasi.
Juga berhati-hati untuk memperhitungkan perbedaan potensi 32-bit, 64-bit dan lainnya yang dapat mempengaruhi representasi numerik.

Tahap: Memeriksa implementasi kompilator peringatan erat dan menghilangkan berpotensi masalah keamanan kritis, seperti ditandatangani / unsigned ketidakcocokan. Bahkan jika kelemahan jarang exploitasi, kegagalan tunggal dapat menyebabkan kompromi seluruh sistem.</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Perlindungan Lapisan Transport yang tidak mencukupi</alert>
	<desc>Perlindungan Lapisan Transport yang tidak mencukupi
Proteksi lapisan transport yang tidak memadai memungkinkan komunikasi terpapar pihak ketiga yang tidak dipercaya, memberikan vektor serangan untuk mengkompromikan aplikasi web dan / atau mencuri informasi sensitif. Situs web biasanya menggunakan Secure Sockets Layer / Transport Layer Security (SSL/TLS) untuk menyediakan enkripsi pada lapisan transport. Namun, kecuali jika situs web dikonfigurasi untuk menggunakan SSL/TLS dan dikonfigurasi untuk menggunakan SSL/TLS dengan benar, situs web mungkin rentan terhadap intersepsi lalu lintas dan modifikasi.
 
Kurangnya Transport Layer Encryption
Bila lapisan transport tidak dienkripsi, semua komunikasi antara situs web dan klien dikirim dalam bentuk teks. yang jelas yang membiarkannya terbuka untuk intersepsi, injeksi dan pengalihan (juga dikenal sebagai serangan man-in-the-middle/MITM). Penyerang dapat secara pasif mencegat komunikasi, memberi mereka akses ke data sensitif yang dikirimkan seperti nama pengguna dan kata sandi. Seorang penyerang juga dapat secara aktif menyuntikkan/menghapus konten dari komunikasi, yang memungkinkan penyerang untuk menempa dan menghilangkan informasi, menyuntikkan script berbahaya, atau menyebabkan klien mengakses konten yang tidak terpercaya. Penyerang juga dapat mengalihkan komunikasi sedemikian rupa sehingga situs web dan klien tidak lagi berkomunikasi satu sama lain, namun secara tidak sadar berkomunikasi dengan penyerang dalam konteks pihak tepercaya lainnya.

Dukungan Cipher Lemah
Secara historis, kriptografi kelas tinggi dibatasi dari ekspor ke luar Amerika Serikat. Karena itu, situs web dikonfigurasi untuk mendukung opsi kriptografi yang lemah untuk klien yang dibatasi hanya menggunakan ciphers lemah. Ciphers lemah rentan diserang karena relatif mudahnya membobolnya; kurang dari dua minggu di komputer rumah khas dan beberapa detik menggunakan perangkat keras khusus.
Ciphers lemah rentan diserang karena relatif mudahnya membobolnya; kurang dari dua minggu di komputer rumah khas dan beberapa detik menggunakan perangkat keras khusus. Karena ini, penyerang mungkin dapat memaksa klien untuk menurunkan versi ke cipher yang lebih lemah saat menghubungkan ke situs web, yang memungkinkan penyerang untuk memecahkan enkripsi yang lemah. Untuk alasan ini, server harus dikonfigurasi untuk hanya menerima ciphers yang kuat dan tidak memberikan layanan kepada klien yang meminta penggunaan cipher yang lebih lemah. Selain itu, beberapa situs web salah dikonfigurasi untuk memilih cipher yang lebih lemah meskipun klien akan mendukung yang lebih kuat. OWASP menawarkan panduan untuk menguji masalah SSL / TLS, termasuk dukungan cipher lemah dan kesalahan konfigurasi, dan ada sumber dan alat lain juga.</desc>
	<solution>Tahap: Persyaratan
Jelas tentukan data atau sumber daya mana yang cukup berharga sehingga harus dilindungi oleh enkripsi. Perlu agar transmisi atau penyimpanan data / sumber daya ini harus menggunakan algoritme enkripsi yang teruji dengan baik.

Tahap: Arsitektur dan Desain
Dengan menggunakan pemodelan ancaman atau teknik lainnya, asumsikan bahwa data Anda dapat dikompromikan melalui kerentanan atau kelemahan yang terpisah, dan menentukan di mana enkripsi akan paling efektif. Ensure that data you believe should be private is not being inadvertently exposed using weaknesses such as insecure permissions (CWE-732).

Tahap: Arsitektur dan Desain
Pastikan enkripsi benar-benar terintegrasi ke dalam perancangan sistem, termasuk namun tidak terbatas pada:
      Enkripsi yang dibutuhkan untuk menyimpan atau mentransmisikan data pribadi pengguna sistem
      Enkripsi yang diperlukan untuk melindungi sistem itu sendiri dari pengungkapan atau gangguan yang tidak sah
Identifikasi kebutuhan dan konteks yang terpisah untuk enkripsi:
      Satu arah (yaitu, hanya pengguna atau penerima yang perlu memiliki kunci). Hal ini dapat dicapai dengan menggunakan kriptografi kunci publik, atau teknik lain di mana pihak yang mengenkripsi (yaitu, perangkat lunak) tidak perlu memiliki akses ke kunci privat.
      Dua arah (yaitu, enkripsi dapat dilakukan secara otomatis atas nama pengguna, namun kuncinya harus tersedia sehingga plainteks dapat dipulihkan secara otomatis oleh pengguna tersebut). Ini memerlukan penyimpanan kunci pribadi dalam format yang dapat dipulihkan hanya oleh pengguna (atau mungkin oleh sistem operasi) dengan cara yang tidak dapat dipulihkan oleh orang lain.

Tahap: Arsitektur dan Desain
Jangan kembangkan algoritma kriptografi Anda sendiri. Mereka kemungkinan akan terpapar serangan yang dipahami dengan baik oleh kriptografer. Teknik teknik reverse sudah matang. Jika algoritma Anda dapat dikompromikan jika penyerang mengetahui cara kerjanya, maka ini sangat lemah.

Tahap: Arsitektur dan Desain
Pilih algoritma well-vetted yang saat ini dianggap kuat oleh para ahli di lapangan, dan pilih implementasi yang teruji dengan baik.
Sebagai contoh, sistem pemerintah AS memerlukan sertifikasi FIPS 140-2.
Seperti semua mekanisme kriptografi, kode sumber harus tersedia untuk analisis.
Secara berkala pastikan Anda tidak menggunakan kriptografi usang. Beberapa algoritma yang lebih tua, yang pernah berpikir membutuhkan waktu komputasi selama satu miliar tahun, sekarang bisa dipatahkan dalam hitungan hari atau jam. Ini termasuk MD4, MD5, SHA1, DES, dan algoritma lainnya yang pernah dianggap kuat.

Tahap: Arsitektur dan Desain
Kompartemen sistem Anda untuk memiliki area "aman" dimana batas kepercayaan dapat ditarik dengan jelas. Jangan biarkan data sensitif keluar dari batas kepercayaan dan selalu berhati-hati saat berinteraksi dengan kompartemen di luar area aman.

Tahapan: Implementasi; Arsitektur dan Desain
Bila Anda menggunakan teknik yang disetujui oleh industri, Anda harus menggunakannya dengan benar. Jangan mengambil jalan pintas dengan melewatkan langkah-langkah intensif sumber daya (CWE-325). Langkah-langkah ini seringkali penting untuk mencegah serangan umum.

Tahap: Implementasi
Gunakan konvensi penamaan dan tipe yang kuat agar lebih mudah dikenali saat data sensitif digunakan. Saat membuat struktur, objek, atau entitas kompleks lainnya, pisahkan data sensitif dan tidak sensitif sebanyak mungkin.
Hal ini mempermudah untuk melihat tempat di kode tempat data digunakan tanpa enkripsi.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Penyertaan File Jarak Jauh</alert>
	<desc>Remote File termasuk (RFI) adalah teknik serangan digunakan untuk memanfaatkan mekanisme "termasuk dinamis file" dalam aplikasi web. Ketika aplikasi web mengambil input pengguna (URL, nilai parameter, dll) dan melewati mereka ke dalam file termasuk perintah, aplikasi web mungkin akan tertipu termasuk remote file dengan kode berbahaya.

Hampir semua kerangka aplikasi web mendukung file inklusi. File inklusi terutama digunakan untuk kemasan kode umum ke dalam file terpisah yang kemudian direferensikan oleh aplikasi utama modul. Ketika aplikasi web referensi file termasuk, kode dalam file ini bisa dijalankan secara implisit ataupun eksplisit dengan memanggil prosedur khusus. Jika pilihan modul untuk memuat didasarkan pada unsur-unsur dari permintaan HTTP, aplikasi web mungkin rentan terhadap RFI.
Penyerang dapat menggunakan RFI untuk: * menjalankan kode berbahaya di server: setiap kode dalam file berbahaya termasuk akan dijalankan oleh server. Jika file include tidak dijalankan menggunakan beberapa wrapper, kode di include file dijalankan dalam konteks pengguna server. Hal ini dapat menyebabkan kompromi sistem yang komplit.
    * Menjalankan kode berbahaya pada klien: kode berbahaya penyerang dapat memanipulasi konten tanggapan yang dikirim ke klien. Penyerang dapat menanamkan kode berbahaya dalam respon yang akan dijalankan oleh klien (misalnya, Javascript untuk mencuri cookie sesi klien).

PHP sangat rentan terhadap serangan RFI karena penggunaan ekstensif "termasuk file" dalam pemrograman PHP dan karena konfigurasi server default yang meningkatkan kerentanan terhadap serangan RFI.</desc>
	<solution>Tahap: Arsitektur dan Desain
Bila kumpulan objek yang dapat diterima, seperti nama file atau URL, terbatas atau diketahui, buat pemetaan dari seperangkat nilai masukan tetap (seperti ID numerik) ke nama file atau URL yang sebenarnya, dan tolak semua masukan lainnya.
Misalnya, ID 1 dapat memetakan ke "inbox.txt" dan ID 2 dapat memetakan ke "profile.txt". Fitur seperti ESAPI AccessReferenceMap memberikan kemampuan ini.

Tahapan: Arsitektur dan Desain; Operasi
Jalankan kode Anda di "penjara" atau lingkungan kotak pasir serupa yang memberlakukan batasan ketat antara proses dan sistem operasi. Ini dapat secara efektif membatasi file mana yang dapat diakses di direktori tertentu atau perintah mana yang dapat dijalankan oleh perangkat lunak Anda.
Contoh tingkat-OS termasuk penjara chroot Unix, AppArmor, dan SELinux. Secara umum, kode yang dikelola mungkin memberikan beberapa perlindungan. Sebagai contoh, java.io.FilePermission di Java SecurityManager memungkinkan Anda untuk menentukan pembatasan pada operasi file.
Ini mungkin bukan solusi yang layak, dan ini hanya membatasi dampaknya terhadap sistem operasi; sisa aplikasi Anda mungkin masih bisa dikompromikan.
Hati-hati untuk menghindari CWE-243 dan kelemahan lain yang terkait dengan penjara.
Bagi PHP, penerjemah menawarkan batasan seperti open basedir atau safe mode yang bisa menyulitkan penyerang untuk melepaskan diri dari aplikasi. Juga pertimbangkan Suhosin, ekstensi PHP yang mengeras, yang mencakup berbagai pilihan yang menonaktifkan beberapa fitur PHP yang lebih berbahaya.

Tahap: Implementasi
Asumsikan semua masukan itu berbahaya. Gunakan strategi validasi masukan "accept known good", i.e., menggunakan daftar putih masukan yang dapat diterima yang sesuai dengan spesifikasi. Tolak masukan apa pun yang tidak sesuai dengan spesifikasi, atau ubah menjadi sesuatu yang tidak. Jangan mengandalkan secara eksklusif untuk mencari masukan jahat atau cacat (i.e., jangan mengandalkan daftar hitam). Namun, blacklist dapat berguna untuk mendeteksi potensi serangan atau menentukan input mana yang salah sehingga harus ditolak secara langsung.
Saat melakukan validasi masukan, pertimbangkan semua properti yang berpotensi relevan, termasuk panjang, jenis masukan, kisaran nilai yang dapat diterima, input yang hilang atau tambahan, sintaksis, konsistensi di bidang terkait, dan kesesuaian dengan peraturan bisnis. Sebagai contoh logika aturan bisnis, "kapal" mungkin sintaksis karena hanya berisi karakter alfanumerik, namun tidak berlaku jika Anda mengharapkan warna seperti "merah" atau "biru". Pastikan Anda melakukan validasi masukan pada antarmuka yang didefinisikan dengan baik di dalam aplikasi. Jika memungkinkan, biarkan saja satu "." karakter dalam nama file untuk menghindari kelemahan seperti CWE-23, dan mengecualikan pemisah direktori seperti "/" untuk menghindari CWE-36. Gunakan daftar putih ekstensi file yang diijinkan, yang akan membantu menghindari CWE-434.

Tahapan: Arsitektur dan Desain; Operasi
Menyimpan perpustakaan, menyertakan, dan file utilitas di luar akar dokumen web, jika memungkinkan. Jika tidak, simpan di direktori terpisah dan gunakan kontrol akses server web untuk mencegah penyerang meminta mereka secara langsung. Salah satu praktik yang umum adalah mendefinisikan konstanta tetap dalam setiap program pemanggilan, kemudian memeriksa keberadaan konstanta dalam file pustaka/include; Jika konstanta tidak ada, maka file itu langsung diminta, dan bisa langsung keluar.
Hal ini secara signifikan mengurangi kemungkinan penyerang dapat melewati mekanisme perlindungan yang ada dalam program dasar namun tidak termasuk file. Ini juga akan mengurangi permukaan serangan Anda.

Tahapan: Arsitektur dan Desain; Pelaksanaan
Pahami semua area potensial dimana masukan yang tidak dipercaya dapat masuk ke perangkat lunak Anda: parameter atau argumen, cookies, apapun yang dibaca dari jaringan, variabel lingkungan, pencarian reverse DNS, hasil query, header permintaan, komponen URL, e-mail, file, database, dan setiap sistem eksternal yang menyediakan data ke aplikasi. Ingat bahwa masukan semacam itu dapat diperoleh secara tidak langsung melalui panggilan API.
Banyak masalah inklusi file terjadi karena pemrogram menganggap bahwa input tertentu tidak dapat dimodifikasi, terutama untuk cookies dan komponen URL.</solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>Format String</alert>
	<desc>Format String Attacks mengubah alur aplikasi dengan menggunakan fitur pemformatan string string untuk mengakses ruang memori lainnya. Kerentanan terjadi ketika data yang dipasok pengguna digunakan secara langsung sebagai input string format untuk fungsi C/C++ tertentu (misalnya fprintf, printf, sprintf, setproctitle, syslog, ...).

Jika penyerang mengeluarkan format string yang terdiri dari karakter konversi printf (misalnya "%f " "%p, "%n", dll.) Sebagai nilai parameter pada aplikasi web, mereka mungkin:
    * Jalankan kode arbitrer pada server
    * Membaca nilai dari tumpukan
    * Menyebabkan kesalahan segmentasi / kerusakan perangkat lunak

 Format Serangan string terkait dengan serangan lain di Ancaman Klasifikasi: Buffer Overflows dan Integer Overflows. Ketiganya didasarkan pada kemampuan mereka untuk memanipulasi memori atau interpretasinya dengan cara yang berkontribusi terhadap tujuan penyerang.</desc>
	<solution>Tahap: Persyaratan
Pilih bahasa yang tidak terkena cacat ini.

Tahap: Implementasi
Pastikan semua fungsi string format dilewatkan string statis yang tidak dapat dikendalikan oleh pengguna dan jumlah argumen yang tepat selalu dikirim ke fungsi itu juga. Jika memungkinkan, gunakan fungsi yang tidak mendukung operator %n dalam format string.
Membangun: Mengindahkan peringatan kompiler dan penghubung, karena mungkin mengingatkan Anda akan penggunaan yang tidak semestinya.
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Buffer Overflow</alert>
	<desc>Sebuah Buffer Overflow adalah cacat yang terjadi ketika lebih banyak data ditulis ke blok memori, atau buffer, daripada buffer yang dialokasikan untuk ditahan. Pemanfaatan buffer overflow memungkinkan penyerang untuk memodifikasi bagian dari ruang proses target '. Kemampuan ini dapat digunakan untuk sejumlah tujuan, termasuk yang berikut ini:
     * Mengontrol eksekusi proses
     * Crash the process
     * Memodifikasi variabel internal Tujuan penyerang hampir selalu mengontrol eksekusi proses target '. Hal ini dilakukan dengan mengidentifikasi pointer fungsi di memori yang dapat dimodifikasi, secara langsung atau tidak langsung, dengan menggunakan overflow. Bila pointer seperti itu digunakan oleh program untuk mengarahkan eksekusi program melalui instruksi lompat atau panggilan, lokasi instruksi yang diberikan penyerang akan digunakan, sehingga memungkinkan penyerang untuk mengendalikan prosesnya.

Dalam banyak kasus, pointer fungsi dimodifikasi untuk merujuk lokasi dimana penyerang telah menempatkan instruksi khusus mesin yang dirakit. Petunjuk ini biasanya disebut sebagai shellcode, mengacu pada fakta bahwa penyerang sering ingin menelurkan lingkungan baris-perintah, atau shell, dalam konteks proses yang berjalan.

Buffer overflows paling sering dikaitkan dengan perangkat lunak yang ditulis dalam bahasa pemrograman C dan C++ karena penggunaan dan kemampuan mereka yang meluas untuk melakukan manipulasi memori langsung dengan pemrograman umum. Perlu ditekankan, bagaimanapun, bahwa buffer overflows dapat ada di lingkungan pemrograman manapun dimana manipulasi memori langsung diperbolehkan, baik melalui kekurangan pada compiler, perpustakaan runtime, atau fitur bahasa itu sendiri.
</desc>
	<solution>Tahap: Arsitektur dan Desain
Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.
Misalnya, banyak bahasa yang menjalankan manajemen memori mereka sendiri, seperti Java dan Perl, tidak tunduk pada buffer overflows. Bahasa lain, seperti Ada dan C#, biasanya memberikan perlindungan melimpah, namun proteksi dapat dinonaktifkan oleh pemrogram.
Berhati-hatilah bahwa antarmuka bahasa ke kode asli mungkin masih mengalami overflow, bahkan jika bahasa itu sendiri secara teoritis aman.

Tahap: Arsitektur dan Desain
Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.
Contohnya termasuk Safe C String Library (SafeStr) oleh Messier dan Viega, dan perpustakaan Strsafe.h dari Microsoft. Perpustakaan ini menyediakan versi yang lebih aman dari fungsi penanganan string overflow rawan. Ini bukan solusi lengkap, karena banyak buffer overflow tidak terkait dengan string.

Tahap: Membangun dan Kompilasi Jalankan atau kompilasi perangkat lunak Anda menggunakan fitur atau ekstensi yang secara otomatis menyediakan mekanisme perlindungan yang mengurangi atau menghilangkan buffer overflows.
Sebagai contoh, kompiler dan ekstensi tertentu menyediakan mekanisme deteksi buffer overflow otomatis yang dibangun ke dalam kode yang dikompilasi. Contohnya termasuk bendera Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY SOURCE GCC, StackGuard, dan ProPolice.

Tahap: Implementasi Pertimbangkan mengikuti peraturan berikut saat mengalokasikan dan mengelola memori aplikasi: Periksa kembali apakah buffer Anda sebesar yang Anda tentukan.
      Bila menggunakan fungsi yang menerima sejumlah byte untuk disalin, seperti strncpy(), perhatikan bahwa jika ukuran buffer tujuan sama dengan ukuran buffer sumber, mungkin tidak NULL-mengakhiri string.
      Periksa batas penyangga jika memanggil fungsi ini dalam satu lingkaran dan pastikan Anda tidak dalam bahaya menulis melewati ruang yang dialokasikan.
      Jika perlu, truncate semua string input dengan panjang yang masuk akal sebelum menyerahkannya ke fungsi copy dan concatenation.

Tahap: Operasi Gunakan fitur seperti Address Space Layout Randomization (ASLR).

Tahap: Operasi

Gunakan CPU dan sistem operasi yang menawarkan Perlindungan Eksekusi Data (NX) atau yang setara.

Tahap: Implementasi

Ganti fungsi copy yang tidak terbatas dengan fungsi analog yang mendukung argumen panjang, seperti strcpy with strncpy. Buat ini jika tidak tersedia.
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Cross-site Scripting</alert>
	<desc>Cross-site Scripting (XSS) adalah teknik serangan yang melibatkan kode penyerang bergema yang disebarkan ke instance browser pengguna. Contoh browser bisa menjadi klien browser web standar, atau objek browser yang disematkan pada produk perangkat lunak seperti browser dalam WinAmp, pembaca RSS, atau klien email. Kode itu sendiri biasanya ditulis dalam HTML/JavaScript, namun mungkin juga mencakup VBScript, ActiveX, Java, Flash, atau teknologi pendukung browser lainnya.
Ketika penyerang mendapatkan browser pengguna untuk mengeksekusi kode nya, kodenya akan berjalan dalam konteks keamanan (atau zona) dari situs web hosting. Dengan tingkat hak istimewa ini, kodenya memiliki kemampuan untuk membaca, memodifikasi dan mengirimkan data sensitif yang dapat diakses oleh browser. Pengguna Scripted Cross-site bisa akunnya dibajak (pencurian cookie), browser mereka diarahkan ke lokasi lain, atau mungkin menunjukkan konten palsu yang disampaikan oleh situs web yang mereka kunjungi. Serangan Cross-site Scripting pada dasarnya membahayakan hubungan kepercayaan antara pengguna dan situs web. Aplikasi yang memanfaatkan instance objek browser yang memuat konten dari sistem file dapat mengeksekusi kode di bawah zona mesin lokal yang memungkinkan kompromi sistem.

Ada tiga jenis serangan Scripting Cross-site: tidak gigih, gigih dan berbasis DOM.
Serangan non-persisten dan serangan berbasis DOM mengharuskan pengguna untuk mengunjungi tautan khusus yang dibuat dengan kode berbahaya, atau mengunjungi laman web berbahaya yang berisi formulir web, yang saat diposkan ke situs yang rentan, akan memasang serangan tersebut. Menggunakan formulir berbahaya seringkali terjadi saat sumber daya yang rentan hanya menerima permintaan HTTP POST. Dalam kasus seperti itu, formulir dapat dikirim secara otomatis, tanpa sepengetahuan korban (misalnya dengan menggunakan JavaScript). Upon clicking on the malicious link or submitting the malicious form, the XSS payload will get echoed back and will get interpreted by the user's browser and execute. Teknik lain untuk mengirim permintaan yang hampir sewenang-wenang (GET dan POST) adalah dengan menggunakan klien tersemat, seperti Adobe Flash.
Serangan yang terus-menerus terjadi saat kode berbahaya dikirimkan ke situs web tempat penyimpanannya disimpan untuk jangka waktu tertentu. Contoh target favorit penyerang sering menyertakan papan pesan, pesan email web, dan perangkat lunak obrolan web. Pengguna yang tidak curiga tidak diharuskan untuk berinteraksi dengan situs / tautan tambahan (misalnya situs penyerang atau tautan jahat yang dikirim melalui email), cukup lihat halaman web yang berisi kode tersebut.</desc>
	<solution>Tahap: Arsitektur dan Desain
Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.
Contoh perpustakaan dan kerangka kerja yang memudahkan menghasilkan keluaran yang dikodekan dengan benar termasuk perpustakaan Anti-XSS Microsoft, modul Encoding OWASP ESAPI, dan Apache Wicket.

Tahapan: Implementasi; Arsitektur dan Desain Memahami konteks dimana data Anda akan digunakan dan pengkodean yang akan diharapkan. Hal ini sangat penting saat mentransmisikan data antar komponen yang berbeda, atau saat menghasilkan keluaran yang dapat berisi beberapa pengkodean sekaligus, seperti halaman web atau pesan email multi-bagian. Pelajari semua protokol komunikasi yang diharapkan dan representasi data untuk menentukan strategi pengkodean yang dibutuhkan.
Untuk data yang akan di output ke halaman web lain, terutama data yang diterima dari input eksternal, gunakan pengkodean yang sesuai pada semua karakter non-alfanumerik.
Konsultasikan XSS pencegahan Cheat Sheet untuk detail lebih lanjut tentang jenis pengkodean dan melarikan diri yang diperlukan.

Tahap: Arsitektur dan desain untuk keamanan setiap pemeriksaan yang dilakukan pada sisi klien, memastikan bahwa pemeriksaan diduplikasi pada sisi server, untuk menghindari CWE-602. Penyerang dapat melewati pemeriksaan sisi klien dengan memodifikasi nilai setelah pemeriksaan dilakukan, atau dengan mengubah klien untuk menghapus pemeriksaan sisi klien sepenuhnya. Kemudian, nilai yang dimodifikasi ini akan diserahkan ke server.

Jika tersedia, gunakan mekanisme terstruktur yang secara otomatis memberlakukan pemisahan antara data dan kode. Mekanisme ini mungkin dapat memberikan kutipan, pengkodean, dan validasi yang relevan secara otomatis, alih-alih mengandalkan pengembang untuk menyediakan kemampuan ini di setiap titik di mana output dihasilkan.

Tahap: Implementasi Untuk setiap halaman web yang dihasilkan, gunakan dan tentukan pengkodean karakter seperti ISO-8859-1 atau UTF-8. Bila pengkodean tidak ditentukan, browser web dapat memilih pengkodean yang berbeda dengan menebak pengkodean mana yang sebenarnya digunakan oleh halaman web. Hal ini dapat menyebabkan browser web memperlakukan urutan tertentu secara khusus, membuka klien dengan serangan XSS yang halus. Lihat CWE-116 untuk lebih banyak mitigasi terkait pengkodean / pelarian.

Untuk membantu mengurangi serangan XSS terhadap cookie sesi pengguna, tetapkan cookie sesi menjadi HttpOnly. Di browser yang mendukung fitur HttpOnly (seperti versi Internet Explorer dan Firefox yang lebih baru), atribut ini dapat mencegah cookie sesi pengguna tidak dapat diakses ke skrip sisi klien berbahaya yang menggunakan document.cookie. Ini bukan solusi yang lengkap, karena HttpOnly tidak didukung oleh semua browser. Lebih penting lagi, XMLHTTPRequest dan teknologi peramban hebat lainnya menyediakan akses baca ke header HTTP, termasuk header Set-Cookie di mana bendera HttpOnly disetel.

Asumsikan semua masukan itu berbahaya Gunakan strategi validasi masukan "accept known good", i.e., menggunakan daftar putih masukan yang dapat diterima yang sesuai dengan spesifikasi. Tolak masukan apa pun yang tidak sesuai dengan spesifikasi, atau ubah menjadi sesuatu yang tidak. Jangan mengandalkan secara eksklusif untuk mencari masukan jahat atau cacat (i.e., jangan mengandalkan daftar hitam). Namun, blacklist dapat berguna untuk mendeteksi potensi serangan atau menentukan input mana yang salah sehingga harus ditolak secara langsung.

Saat melakukan validasi masukan, pertimbangkan semua properti yang berpotensi relevan, termasuk panjang, jenis masukan, kisaran nilai yang dapat diterima, input yang hilang atau tambahan, sintaksis, konsistensi di bidang terkait, dan kesesuaian dengan peraturan bisnis. Sebagai contoh logika aturan bisnis, "kapal" mungkin sintaksis karena hanya berisi karakter alfanumerik, namun tidak berlaku jika Anda mengharapkan warna seperti "merah" atau "biru". Pastikan Anda melakukan validasi masukan pada antarmuka yang didefinisikan dengan baik di dalam aplikasi. Ini akan membantu melindungi aplikasi meskipun komponen digunakan kembali atau dipindahkan ke tempat lain.
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Pemalsuan Permintaan Situs melintasi</alert>
	<desc>Permintaan pemalsuan lintas situs adalah serangan yang melibatkan pemaksaan korban untuk mengirim permintaan HTTP ke tujuan target tanpa sepengetahuan atau niat mereka untuk melakukan tindakan sebagai korban. Penyebab utamanya adalah fungsionalitas aplikasi dengan menggunakan URL / bentuk aksi yang dapat diprediksi dengan cara yang berulang. Sifat serangannya adalah bahwa CSRF mengeksploitasi kepercayaan yang dimiliki situs web bagi pengguna. Sebaliknya, lintas-situs penulisan (XSS) mengeksploitasi kepercayaan yang dimiliki pengguna untuk situs web. Seperti XSS, serangan CSRF belum tentu situs-lintas, tapi bisa juga. Permintaan pemalsuan lintas situs juga dikenal sebagai CSRF, XSRF, serangan satu klik, sesi berkuda, deputi bingung, dan ombak laut.

Serangan CSRF efektif dalam sejumlah situasi, termasuk:
     * Korban memiliki sesi aktif di lokasi sasaran.
    * Korban diautentikasi via HTTP asli di situs target.
    * Korban berada di jaringan lokal yang sama dengan lokasi sasaran.

CSRF terutama digunakan untuk melakukan tindakan terhadap situs target dengan menggunakan hak istimewa korban, namun teknik terbaru telah ditemukan untuk mengungkapkan informasi dengan mendapatkan akses terhadap tanggapan tersebut. Risiko pengungkapan informasi meningkat secara dramatis ketika situs target rentan terhadap XSS, karena XSS dapat digunakan sebagai tanda untuk CSRF, yang memungkinkan serangan beroperasi dalam batas-batas kebijakan asal yang sama.</desc>
	<solution>Tahap: Arsitektur dan Desain
Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.
Misalnya, gunakan paket anti-CSRF seperti CSRFGuard OWASP.

Tahap: Implementasi Pastikan aplikasi Anda bebas dari masalah penulisan lintas situs, karena kebanyakan pertahanan CSRF dapat dilewati menggunakan skrip yang dikendalikan oleh penyerang.

Fase: Arsitektur dan Desain Hasilkan sebuah unce unik untuk setiap bentuk, letakkan unce ke dalam bentuk, dan verifikasi unce setelah menerima formulir. Pastikan bahwa bukan tidak dapat diprediksi (CWE-330).
Perhatikan bahwa ini bisa dilewati dengan menggunakan XSS.

Dentifikasi operasi yang sangat berbahaya. Saat pengguna melakukan operasi berbahaya, kirim permintaan konfirmasi terpisah untuk memastikan pengguna berniat melakukan operasi itu.
Perhatikan bahwa ini bisa dilewati dengan menggunakan XSS.

Gunakan kontrol Manajemen Sesi ESAPI.
Kontrol ini mencakup komponen untuk CSRF.

Jangan gunakan metode GET untuk setiap permintaan yang memicu perubahan status.

Tahap: Implementasi Periksa header Referral HTTP untuk melihat apakah permintaan berasal dari halaman yang diharapkan. Ini bisa melanggar fungsi yang sah, karena pengguna atau proxy mungkin telah menonaktifkan pengiriman Rujukan karena alasan privasi.</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Penyangkalan dari Layanan</alert>
	<desc>Penyangkalan dari Layanan (DoS) adalah teknik serangan dengan maksud mencegah situs web melayani aktivitas pengguna normal. Serangan DoS, yang mudah diterapkan pada lapisan jaringan, juga dimungkinkan di lapisan aplikasi. Serangan berbahaya ini bisa berhasil dengan kelaparan dengan sistem sumber daya kritis, kerentanan mengeksploitasi, atau penyalahgunaan fungsi.

Seringkali serangan DoS akan mencoba untuk mengkonsumsi semua sumber daya sistem yang tersedia di situs web seperti: CPU, memori, ruang penyimpanan, dll. Bila salah satu dari sumber daya kritis ini mencapai pemanfaatan penuh, situs web biasanya tidak dapat diakses.

Seperti lingkungan aplikasi web saat ini termasuk server web, server database dan server otentikasi, DoS di lapisan aplikasi dapat menargetkan masing-masing komponen independen ini. Tidak seperti DoS di lapisan jaringan, di mana sejumlah besar upaya koneksi diperlukan, DoS pada lapisan aplikasi adalah tugas yang lebih sederhana untuk dilakukan.</desc>
	<solution>Tahap: Arsitektur dan Desain Mendesain mekanisme ruang sempit ke dalam arsitektur sistem. Perlindungan terbaik adalah membatasi jumlah sumber daya yang mungkin menyebabkan pengguna yang tidak sah dikeluarkan. Model otentikasi dan kontrol akses yang kuat akan membantu mencegah serangan semacam itu terjadi. Aplikasi masuk harus dilindungi terhadap serangan DoS sebanyak mungkin. Membatasi akses database, mungkin dengan hasil set menyembunyikan, dapat membantu meminimalkan sumber daya yang dikeluarkan. Untuk lebih membatasi potensi serangan DoS, pertimbangkan untuk melacak tingkat permintaan yang diterima dari pengguna dan memblokir permintaan yang melebihi ambang batas tingkat yang ditetapkan.

Mitigasi serangan kelelahan sumber daya mengharuskan sistem target:
       mengenali serangan tersebut dan menolak akses pengguna lebih jauh untuk jangka waktu tertentu, atau
       Secara seragam mencekal semua permintaan agar lebih sulit untuk mengkonsumsi sumber daya lebih cepat daripada yang bisa mereka bebaskan lagi. 

Solusi pertama adalah masalah tersendiri, karena memungkinkan penyerang untuk mencegah penggunaan sistem oleh pengguna tertentu yang sah. Jika penyerang meniru identitas pengguna yang valid, dia mungkin bisa mencegah pengguna mengakses server yang bersangkutan.

Solusi kedua hanya sulit untuk dilembagakan secara efektif -- dan bahkan jika dilakukan dengan benar, solusi ini tidak memberikan solusi penuh. Itu hanya membuat serangan membutuhkan lebih banyak sumber daya dari pihak penyerang.

Pastikan bahwa protokol memiliki batas skala tertentu yang ditempatkan pada mereka.

Tahap: Implementasi
Pastikan semua kegagalan dalam alokasi sumber daya menempatkan sistem ke dalam postur tubuh yang aman.</solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Brute Forcing Log-in Kredensial</alert>
	<desc>Serangan brute force adalah metode untuk menentukan nilai yang tidak diketahui dengan menggunakan proses otomatis untuk mencoba sejumlah besar nilai yang mungkin terjadi. Serangan tersebut memanfaatkan kenyataan bahwa entropi nilai lebih kecil dari yang dirasakan. Misalnya, sementara kata sandi alfanumerik 8 karakter dapat menghasilkan 2,8 triliun nilai yang mungkin, banyak orang akan memilih kata sandinya dari subset yang jauh lebih kecil yang terdiri dari kata dan istilah umum.

Jenis serangan brute force yang paling umum dalam aplikasi web adalah serangan terhadap kredensial log-in. Karena pengguna perlu mengingat kata kunci, mereka sering memilih untuk mudah mengingat kata atau frasa sebagai kata kunci, membuat serangan kasar menggunakan kamus yang berguna. Serangan seperti itu mencoba masuk ke sistem menggunakan daftar kata dan frase yang besar karena kata kunci potensial sering disebut "serangan daftar kata" atau "serangan kamus". Kata kunci yang dicoba juga mencakup variasi kata-kata yang umum untuk kata sandi seperti yang dihasilkan dengan mengganti "o" dengan "0" dan "i" dengan "1" serta informasi pribadi termasuk nama anggota keluarga, tanggal lahir dan telepon mati rasa.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Brute Memaksa Session Identifiers</alert>
	<desc>Serangan brute force adalah metode untuk menentukan nilai yang tidak diketahui dengan menggunakan proses otomatis untuk mencoba sejumlah besar nilai yang mungkin terjadi. Serangan tersebut memanfaatkan kenyataan bahwa entropi nilai lebih kecil dari yang dirasakan. Misalnya, sementara kata sandi alfanumerik 8 karakter dapat menghasilkan 2,8 triliun nilai yang mungkin, banyak orang akan memilih kata sandinya dari subset yang jauh lebih kecil yang terdiri dari kata dan istilah umum.

Karena HTTP adalah protokol tanpa kewarganegaraan, untuk mempertahankan aplikasi web negara perlu memastikan bahwa pengenal sesi dikirim oleh peramban dengan setiap permintaan. Pengenal sesi paling sering disimpan dalam cookie HTTP atau URL. Dengan menggunakan serangan brute force, penyerang bisa menebak pengenal sesi pengguna lain. Hal ini dapat menyebabkan penyerang meniru identitas pengguna, mengambil informasi pribadi dan melakukan tindakan atas nama pengguna.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Brute Memaksa Direktori dan File</alert>
	<desc>Serangan brute force adalah metode untuk menentukan nilai yang tidak diketahui dengan menggunakan proses otomatis untuk mencoba sejumlah besar nilai yang mungkin terjadi. Serangan tersebut memanfaatkan kenyataan bahwa entropi nilai lebih kecil dari yang dirasakan. Misalnya, sementara kata sandi alfanumerik 8 karakter dapat menghasilkan 2,8 triliun nilai yang mungkin, banyak orang akan memilih kata sandinya dari subset yang jauh lebih kecil yang terdiri dari kata dan istilah umum.

Ketika file berada di direktori yang dilayani oleh server web namun tidak terhubung di manapun, mengakses file tersebut memerlukan mengetahui nama file mereka. Dalam beberapa kasus, file-file tersebut telah ditinggalkan karena kesalahan: misalnya file cadangan yang dibuat secara otomatis saat mengedit file atau sisa dari versi lama aplikasi web. Dalam kasus lain, file sengaja dibatalkan karena mekanisme "keamanan oleh ketidakjelasan" yang memungkinkan hanya orang-orang yang mengetahui nama file untuk mengaksesnya.

Serangan brute force mencoba menemukan file yang tidak terhubung dengan mencoba mengakses sejumlah besar file. Daftar nama file percobaan mungkin diambil dari daftar file potensial yang diketahui atau berdasarkan varian dari file yang terlihat di situs web. Informasi lebih lanjut tentang direktori dan file kasar dapat ditemukan di kerentanan terkait, lokasi sumber yang dapat diprediksi.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Informasi Kartu Kredit Brute Forcing</alert>
	<desc>Serangan brute force adalah metode untuk menentukan nilai yang tidak diketahui dengan menggunakan proses otomatis untuk mencoba sejumlah besar nilai yang mungkin terjadi. Serangan tersebut memanfaatkan kenyataan bahwa entropi nilai lebih kecil dari yang dirasakan. Misalnya, sementara kata sandi alfanumerik 8 karakter dapat menghasilkan 2,8 triliun nilai yang mungkin, banyak orang akan memilih kata sandinya dari subset yang jauh lebih kecil yang terdiri dari kata dan istilah umum.

Belanja online dengan kartu kredit curian biasanya memerlukan informasi selain nomor kartu kredit, paling sering CVV/SCS dan/atau tanggal kedaluwarsa. Penipu dapat memegang nomor kartu kredit curian tanpa informasi tambahan. Misalnya CVV/CSC tidak tercetak pada kartu atau disimpan pada garis magnetik sehingga tidak dapat dikumpulkan dengan kartu sweeping kartu memori mekanis atau magnetik.

Untuk mengisi informasi yang hilang, si hacker bisa menebak informasi yang hilang dengan menggunakan teknik kekerasan, mencoba semua kemungkinan nilai.
    * Menebak CVV/CSC hanya memerlukan 1000 atau 10000 usaha karena jumlahnya hanya 3 atau 4 digit, tergantung pada jenis kartunya.
    * Menebak tanggal kadaluwarsa hanya membutuhkan beberapa lusin usaha.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>Konten Spoofing</alert>
	<desc>Content Spoofing adalah teknik serangan yang memungkinkan penyerang untuk menyuntikkan muatan berbahaya yang kemudian disalahartikan sebagai konten sah dari aplikasi web.
 
Text Only Content Spoofing Pendekatan umum untuk membangun halaman secara dinamis melibatkan pelepasan tubuh atau bagiannya ke halaman melalui nilai string kueri. Pendekatan ini biasa terjadi pada halaman kesalahan, atau situs yang menyediakan berita atau berita. Konten yang ditentukan dalam parameter ini kemudian tercermin ke dalam halaman untuk menyediakan konten halaman.
 
Spoofing Spektrofotometri Markup Beberapa halaman web disajikan menggunakan sumber konten HTML yang dibuat secara dinamis. Misalnya, lokasi sumber dari bingkai <frame src="http://foo.example/file.html"/>) dapat ditentukan oleh nilai parameter URL. (http://foo.example/page? frame_src=http://foo.example/file.html). Seorang penyerang mungkin bisa mengganti nilai parameter "frame_src" dengan "frame_src = http: //attacker.example/spoof.html". Tidak seperti redirectors, ketika halaman web yang dihasilkan disajikan, bar lokasi browser terlihat berada di bawah domain yang diharapkan pengguna (foo.example), namun data asing (penyerang.example) diselimuti oleh konten yang sah.

Tautan khusus yang dibuat dapat dikirim ke pengguna melalui e-mail, pesan instan, tertinggal di papan buletin, atau dipaksa oleh pengguna oleh serangan Scripting Cross-site. Jika penyerang mendapatkan pengguna untuk mengunjungi halaman web yang ditunjuk oleh URL jahat mereka, pengguna akan yakin bahwa dia melihat konten asli dari satu lokasi jika tidak. Pengguna secara implisit akan mempercayai konten palsu tersebut karena bilah lokasi browser menampilkan http: //foo.example, padahal sebenarnya kerangka HTML yang mendasari merujuk http: //attacker.example.

Serangan ini mengeksploitasi hubungan kepercayaan yang terjalin antara pengguna dan situs web. Teknik ini telah digunakan untuk membuat halaman web palsu termasuk form login, defacements, false press release, etc.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Kebocoran Informasi</alert>
	<desc>Informasi Kebocoran adalah kelemahan aplikasi dimana sebuah aplikasi mengungkapkan data sensitif, seperti rincian teknis aplikasi web, lingkungan, atau data khusus pengguna. Data sensitif dapat digunakan oleh penyerang untuk mengeksploitasi aplikasi web target, jaringan hosting, atau penggunanya. Oleh karena itu, kebocoran data sensitif harus dibatasi atau dicegah bila memungkinkan. Kebocoran informasi, dalam bentuknya yang paling umum, adalah hasil dari satu atau lebih dari kondisi berikut: Kegagalan untuk menggandakan komentar HTML/Script yang berisi informasi sensitif, konfigurasi aplikasi atau server yang tidak semestinya, atau perbedaan dalam tanggapan halaman untuk data yang valid dan tidak valid.

Kegagalan untuk menggosok komentar HTML / Script sebelum melakukan push ke lingkungan produksi dapat mengakibatkan kebocoran informasi sensitif, kontekstual, seperti struktur direktori server, struktur query SQL, dan informasi jaringan internal. Seringkali pengembang akan meninggalkan komentar dalam HTML dan / atau kode skrip untuk membantu memudahkan proses debugging atau integrasi selama fase pra-produksi. Meskipun tidak ada salahnya membiarkan pengembang menyertakan komentar sebaris di dalam konten yang mereka kembangkan, komentar ini semua harus dihapus sebelum rilis publik konten.

Nomor versi perangkat lunak dan pesan kesalahan verbose (seperti nomor versi ASP.NET) adalah contoh konfigurasi server yang tidak semestinya. Informasi ini berguna bagi penyerang dengan memberikan wawasan rinci mengenai kerangka kerja, bahasa, atau fungsi pra-bangun yang digunakan oleh aplikasi web. Sebagian besar konfigurasi server default menyediakan nomor versi perangkat lunak dan pesan kesalahan verbose untuk tujuan debug dan pemecahan masalah. Perubahan konfigurasi dapat dilakukan untuk menonaktifkan fitur ini, mencegah tampilan informasi ini.

Laman yang memberikan tanggapan berbeda berdasarkan validitas data juga dapat menyebabkan Kebocoran Informasi; khususnya ketika data dianggap rahasia sedang diungkapkan sebagai hasil dari desain aplikasi web. Contoh data sensitif termasuk (namun tidak terbatas pada): nomor rekening, pengenal pengguna (nomor lisensi Driver, nomor Paspor, Nomor Jaminan Sosial, dll.) Dan informasi khusus pengguna (kata sandi, sesi, alamat). Informasi Kebocoran dalam konteks ini berkaitan dengan pemaparan data pengguna kunci yang dianggap rahasia, atau rahasia, yang seharusnya tidak terpapar secara polos, bahkan untuk pengguna. Nomor kartu kredit dan informasi lain yang sangat diatur adalah contoh utama data pengguna yang perlu dilindungi lebih jauh dari paparan atau kebocoran bahkan dengan enkripsi dan kontrol akses yang benar.</desc>
	<solution>Kompartemen sistem Anda untuk memiliki area "aman" dimana batas kepercayaan dapat ditarik dengan jelas. Jangan biarkan data sensitif keluar dari batas kepercayaan dan selalu berhati-hati saat berinteraksi dengan kompartemen di luar area aman.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Server Misconfiguration</alert>
	<desc>Server Misconfiguration serangan memanfaatkan kelemahan konfigurasi yang ditemukan di server web dan server aplikasi. Banyak server datang dengan file default dan sampel yang tidak perlu, termasuk aplikasi, file konfigurasi, skrip, dan halaman web. Mereka mungkin juga mengaktifkan layanan yang tidak perlu, seperti pengelolaan konten dan fungsi administrasi jarak jauh. Fungsi debug mungkin diaktifkan atau fungsi administratif dapat diakses oleh pengguna anonim. Fitur-fitur ini dapat memberi sarana bagi hacker untuk melewati metode otentikasi dan mendapatkan akses ke informasi sensitif, mungkin dengan hak istimewa yang tinggi.

Server mungkin termasuk akun default dan kata sandi yang terkenal. Gagal untuk sepenuhnya mengunci atau mengeras server dapat meninggalkan file dan hak akses direktori yang tidak semestinya. Sertifikat SSL dan pengaturan enkripsi yang salah dikonfigurasi, penggunaan sertifikat default, dan penerapan otentikasi yang tidak benar dengan sistem eksternal dapat membahayakan kerahasiaan informasi.

Pesan kesalahan Verbose dan informatif dapat menyebabkan kebocoran data, dan informasi yang terungkap dapat digunakan untuk merumuskan tingkat serangan berikutnya. Salah konfigurasi pada perangkat lunak server memungkinkan pengindeksan direktori dan serangan traversal path.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Kesalahan konfigurasi aplikasi</alert>
	<desc>Serangan Misconfiguration Aplikasi memanfaatkan kelemahan konfigurasi yang terdapat pada aplikasi web. Banyak aplikasi hadir dengan fitur yang tidak perlu dan tidak aman, seperti fitur debug dan QA, yang diaktifkan secara default. Fitur-fitur ini dapat memberi sarana bagi hacker untuk melewati metode otentikasi dan mendapatkan akses ke informasi sensitif, mungkin dengan hak istimewa yang tinggi.

Demikian juga, instalasi default dapat mencakup nama pengguna dan kata kunci yang terkenal, akun backdoor dengan kode keras, mekanisme akses khusus, dan izin yang salah untuk file yang dapat diakses melalui server web. Sampel standar dapat diakses di lingkungan produksi. File konfigurasi berbasis aplikasi yang tidak terkunci dengan benar dapat mengungkapkan string koneksi teks yang jelas ke database, dan pengaturan default pada file konfigurasi mungkin tidak diatur dengan keamanan. Semua kesalahan konfigurasi ini dapat menyebabkan akses tidak sah ke informasi sensitif.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Pengindeksan direktori</alert>
	<desc>Daftar/pengindeksan direktori otomatis adalah fungsi server web yang mencantumkan semua file dalam direktori yang diminta jika file basis normal (index.html/home.html/ default.htm/default.asp/default.aspx/index.php) tidak hadir. Saat pengguna meminta halaman utama situs web, mereka biasanya mengetikkan URL seperti: http://www.example.com/directory1/ - menggunakan nama domain dan tidak termasuk file tertentu. Server web memproses permintaan ini dan mencari direktori root dokumen untuk nama file default dan mengirimkan halaman ini ke klien. Jika halaman ini tidak ada, server web akan secara dinamis mengeluarkan daftar direktori dan mengirimkan hasilnya ke klien. Intinya, ini sama dengan mengeluarkan perintah "ls" (Unix) atau "dir" (Windows) di dalam direktori ini dan menunjukkan hasilnya dalam bentuk HTML. Dari perspektif penyerangan dan penanggulangan, penting untuk disadari bahwa daftar direktori yang tidak diinginkan mungkin terjadi karena kerentanan perangkat lunak (dibahas di bagian contoh di bawah) dikombinasikan dengan permintaan web tertentu.</desc>
	<solution>Rekomendasi termasuk membatasi akses ke direktori atau file penting dengan mengadopsi kebutuhan untuk mengetahui persyaratan baik untuk akar dokumen dan server, dan mematikan fitur seperti Direktori Otomatis yang dapat mengekspos file pribadi dan memberikan informasi yang dapat digunakan oleh penyerang saat merumuskan atau melakukan serangan</solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Izin Filesystem yang Tidak Tepat</alert>
	<desc>Izin filesystem yang tidak benar merupakan ancaman terhadap kerahasiaan, integritas dan ketersediaan aplikasi web. Masalah muncul saat hak akses filesystem salah diatur pada file, folder, dan tautan simbolis. Bila izin yang tidak semestinya ditetapkan, penyerang mungkin dapat mengakses file atau direktori yang dibatasi dan memodifikasi atau menghapus isinya. Misalnya, jika akun pengguna anonim telah menulis izin ke sebuah file, maka penyerang mungkin dapat memodifikasi isi file yang mempengaruhi aplikasi web dengan cara yang tidak diinginkan. Penyerang juga dapat memanfaatkan symlink yang tidak tepat untuk meningkatkan hak istimewa mereka dan/atau mengakses file yang tidak sah; Misalnya, symlink yang menunjuk ke direktori di luar root web.</desc>
	<solution>Sangat hati-hati mengatur pengaturan, pengelolaan dan penanganan perizinan. Secara eksplisit mengelola zona kepercayaan dalam perangkat lunak.</solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Prediksi Kredensial dan Sesi</alert>
	<desc>Prediksi Kredensial/Sesi adalah metode pembajakan atau peniruan identitas pengguna situs web. Mengumpulkan atau menebak nilai unik yang mengidentifikasi sesi tertentu atau pengguna menyelesaikan serangan. Juga dikenal sebagai Session Hijacking, konsekuensinya memungkinkan penyerang kemampuan untuk mengeluarkan permintaan situs web dengan hak istimewa pengguna yang dikompromikan.

Banyak situs web dirancang untuk mengotentikasi dan melacak pengguna saat komunikasi pertama kali didirikan. Untuk melakukan ini, pengguna harus membuktikan identitas mereka ke situs web, biasanya dengan memberikan kombinasi nama pengguna/kata sandi (kredensial). Daripada menyampaikan kredensial rahasia ini bolak-balik dengan setiap transaksi, situs web akan menghasilkan "ID sesi" yang unik untuk mengidentifikasi sesi pengguna sebagai hal yang otentik. Komunikasi selanjutnya antara pengguna dan situs web ditandai dengan ID sesi sebagai "bukti" dari sesi yang dikonfirmasi. Jika penyerang dapat memprediksi atau menebak ID sesi pengguna lain, aktivitas penipuan mungkin dilakukan.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference></reference>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL Injection</alert>
	<desc>SQL Injection adalah teknik serangan yang digunakan untuk mengeksploitasi aplikasi yang membuat pernyataan SQL dari masukan yang diberikan pengguna. Bila berhasil, penyerang mampu mengubah logika pernyataan SQL yang dijalankan terhadap database.

Structured Query Language (SQL) adalah bahasa pemrograman khusus untuk mengirimkan query ke database. Bahasa pemrograman SQL adalah standar ANSI dan ISO, walaupun banyak produk database yang mendukung SQL melakukannya dengan ekstensi proprietary ke bahasa standar. Aplikasi sering menggunakan data yang disediakan pengguna untuk membuat pernyataan SQL. Jika sebuah aplikasi gagal untuk benar membangun pernyataan SQL adalah mungkin bagi penyerang untuk mengubah struktur pernyataan dan mengeksekusi perintah yang tidak terencana dan berpotensi bermusuhan. Ketika perintah tersebut dijalankan, mereka melakukannya di bawah konteks pengguna yang ditentukan oleh aplikasi yang menjalankan pernyataan tersebut. Kemampuan ini memungkinkan penyerang untuk menguasai semua sumber database yang dapat diakses oleh pengguna tersebut, sampai dan termasuk kemampuan untuk menjalankan perintah pada sistem hosting.</desc>
	<solution>Tahap: Arsitektur dan Desain
Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.
Misalnya, pertimbangkan untuk menggunakan lapisan ketekunan seperti Hibernate atau Enterprise Java Beans, yang dapat memberikan perlindungan signifikan terhadap injeksi SQL jika digunakan dengan benar.

Jika tersedia, gunakan mekanisme terstruktur yang secara otomatis memberlakukan pemisahan antara data dan kode. Mekanisme ini mungkin dapat memberikan kutipan, pengkodean, dan validasi yang relevan secara otomatis, alih-alih mengandalkan pengembang untuk menyediakan kemampuan ini di setiap titik di mana output dihasilkan.

Proses query SQL menggunakan pernyataan disiapkan, parameterized queries, atau stored procedure. Fitur ini harus menerima parameter atau variabel dan mendukung pengetikan yang kuat. Jangan membuat dan menjalankan string permintaan secara dinamis dalam fitur ini menggunakan fungsi "exec" atau yang serupa, karena Anda dapat mengenalkan kembali kemungkinan injeksi SQL.

Jalankan kode Anda dengan menggunakan hak istimewa terendah yang diperlukan untuk menyelesaikan tugas yang diperlukan. Jika memungkinkan, buat akun terisolasi dengan hak istimewa terbatas yang hanya digunakan untuk satu tugas tunggal. Dengan begitu, serangan yang berhasil tidak akan segera memberi penyerang akses ke perangkat lunak atau lingkungan lainnya. Sebagai contoh, aplikasi database jarang perlu dijalankan sebagai administrator database, terutama dalam operasi sehari-hari.

Sebagai contoh, aplikasi database jarang perlu dijalankan sebagai database administrator, di dalam operasi sehari-hari. Pengguna database seharusnya hanya memiliki hak istimewa minimum yang diperlukan untuk menggunakan akun mereka. Jika persyaratan sistem menunjukkan bahwa pengguna dapat membaca dan memodifikasi data mereka sendiri, maka batasi hak istimewa mereka sehingga mereka tidak dapat membaca/menulis data orang lain. Gunakan hak akses yang paling ketat pada semua objek database, seperti execute-only untuk stored procedure.

Tahap: Implementasi
Jika Anda perlu menggunakan string kueri atau perintah kueri yang dihasilkan secara dinamis terlepas dari risikonya, berikan argumen dengan benar dan lepaskan karakter khusus apa pun dalam argumen tersebut. Pendekatan yang paling konservatif adalah melarikan diri atau menyaring semua karakter yang tidak melewati daftar putih yang sangat ketat (seperti segala sesuatu yang bukan spasial atau spasi putih). Jika beberapa karakter khusus masih dibutuhkan, seperti white space, bungkus setiap argumen dalam tanda kutip setelah langkah escape/filtering. Hati-hati dengan injeksi argumen (CWE-88).

Alih-alih membangun penerapan Anda sendiri, fitur semacam itu mungkin tersedia dalam database atau bahasa pemrograman. Misalnya, paket Oracle DBMS ASSERT dapat memeriksa atau menerapkan parameter tersebut memiliki sifat tertentu yang membuat mereka kurang rentan terhadap injeksi SQL. Untuk MySQL, mysql string escape nyata() fungsi API tersedia di kedua C dan PHP.

Asumsikan semua masukan itu berbahaya Gunakan strategi validasi masukan "accept known good", i.e., menggunakan daftar putih masukan yang dapat diterima yang sesuai dengan spesifikasi. Tolak masukan apa pun yang tidak sesuai dengan spesifikasi, atau ubah menjadi sesuatu yang tidak. Jangan mengandalkan secara eksklusif untuk mencari masukan jahat atau cacat (i.e., jangan mengandalkan daftar hitam). Namun, blacklist dapat berguna untuk mendeteksi potensi serangan atau menentukan input mana yang salah sehingga harus ditolak secara langsung.

Saat melakukan validasi masukan, pertimbangkan semua properti yang berpotensi relevan, termasuk panjang, jenis masukan, kisaran nilai yang dapat diterima, input yang hilang atau tambahan, sintaksis, konsistensi di bidang terkait, dan kesesuaian dengan peraturan bisnis. Sebagai contoh logika aturan bisnis, "kapal" mungkin sintaksis karena hanya berisi karakter alfanumerik, namun tidak berlaku jika Anda mengharapkan warna seperti "merah" atau "biru".

Saat membuat string perintah SQL, gunakan whitelist ketat yang membatasi set karakter berdasarkan nilai parameter yang diharapkan dalam permintaan. Ini secara tidak langsung akan membatasi lingkup serangan, namun teknik ini kurang penting daripada pengkodean output yang tepat dan melarikan diri.

Perhatikan bahwa pengkodean output yang tepat, melarikan diri, dan mengutip adalah solusi paling efektif untuk mencegah injeksi SQL, walaupun validasi masukan mungkin memberikan beberapa pertahanan yang mendalam. Hal ini karena secara efektif membatasi apa yang akan muncul dalam output. Validasi masukan tidak akan selalu mencegah injeksi SQL, terutama jika Anda diminta untuk mendukung bidang teks formulir bebas yang dapat mengandung karakter sewenang-wenang. Misalnya, nama "O'Reilly" kemungkinan akan melewati tahap validasi, karena ini adalah nama belakang yang umum dalam bahasa Inggris. Namun, tidak bisa langsung dimasukkan ke dalam database karena mengandung karakter apostrof "'" yang harus diloloskan atau ditangani. Dalam kasus ini, pengupasan apostrof bisa mengurangi risiko injeksi SQL, namun akan menghasilkan perilaku yang salah karena nama yang salah akan dicatat.

Bila memungkinkan, mungkin paling aman untuk melarang meta-karakter sama sekali, alih-alih melarikan diri dari mereka. Ini akan memberikan beberapa pertahanan secara mendalam. Setelah data dimasukkan ke dalam database, proses selanjutnya dapat diabaikan untuk menghindari karakter meta sebelum digunakan, dan Anda mungkin tidak memiliki kontrol atas proses tersebut.</solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference></reference>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Penanganan Masukan yang Tidak Tepat</alert>
	<desc>Penanganan masukan yang salah adalah salah satu kelemahan yang paling umum diidentifikasi di seluruh aplikasi saat ini. Masukan yang ditangani dengan buruk adalah penyebab utama di balik kerentanan kritis yang ada dalam sistem dan aplikasi.
	
Umumnya, istilah input handing digunakan untuk menggambarkan fungsi seperti validasi, sanitasi, penyaringan, pengkodean dan/atau decoding data masukan. Aplikasi menerima masukan dari berbagai sumber termasuk pengguna manusia, agen perangkat lunak (browser), dan perangkat jaringan/periferal untuk beberapa nama. Dalam kasus aplikasi web, masukan dapat ditransfer dalam berbagai format (pasangan nilai nama, JSON, SOAP, dll..) dan diperoleh melalui string kueri URL, data POST, header HTTP, Cookie, dll... Masukan aplikasi non-web dapat diperoleh melalui variabel aplikasi, variabel lingkungan, registry, file konfigurasi, dll... Terlepas dari format data atau sumber/lokasi input, semua masukan harus dianggap tidak dipercaya dan berpotensi berbahaya. Aplikasi yang memproses masukan yang tidak dipercaya dapat menjadi rentan terhadap serangan seperti Buffer Overflows, SQL Injection, OS Commanding, Denial of Service hanya untuk beberapa nama.

Salah satu aspek kunci penanganan input adalah memvalidasi bahwa input tersebut memenuhi kriteria tertentu. Untuk validasi yang benar, penting untuk mengidentifikasi bentuk dan jenis data yang dapat diterima dan diharapkan oleh aplikasi. Mendefinisikan format yang diharapkan dan penggunaan setiap instance input yang tidak dipercaya diperlukan untuk mendefinisikan batasan secara akurat. 

Validasi dapat mencakup pemeriksaan untuk jenis keselamatan dan sintaks yang benar. Masukan string dapat diperiksa untuk panjang (jumlah min dan max karakter) dan validasi karakter set sedangkan jenis input numerik seperti bilangan bulat dan desimal dapat divalidasi terhadap batas nilai atas dan bawah yang dapat diterima. Saat menggabungkan masukan dari banyak sumber, validasi harus dilakukan selama penggabungan dan tidak hanya terhadap elemen data individual. Praktik ini membantu menghindari situasi di mana validasi masukan dapat berhasil bila dilakukan pada item data individual namun gagal bila dilakukan pada gabungan gabungan dari semua sumber.</desc>
	<solution>Gunakan kerangka validasi masukan seperti Struts atau OWASP ESAPI Validasi API.

Pahami semua area potensial dimana masukan yang tidak dipercaya dapat masuk ke perangkat lunak Anda: parameter atau argumen, cookies, apapun yang dibaca dari jaringan, variabel lingkungan, pencarian reverse DNS, hasil query, header permintaan, komponen URL, e-mail, file, database, dan setiap sistem eksternal yang menyediakan data ke aplikasi. Ingat bahwa masukan semacam itu dapat diperoleh secara tidak langsung melalui panggilan API.

Untuk pemeriksaan keamanan yang dilakukan di sisi klien, pastikan pemeriksaan ini diduplikasi di sisi server. Penyerang dapat melewati pemeriksaan sisi klien dengan memodifikasi nilai setelah pemeriksaan dilakukan, atau dengan mengubah klien untuk menghapus pemeriksaan sisi klien sepenuhnya. Kemudian, nilai yang dimodifikasi ini akan diserahkan ke server.

Meskipun pengecekan sisi-klien memberikan minimal manfaat dengan menghargai keamanan sisi-server, meraka tetap berguna. Pertama, mereka bisa mendukung deteksi intrusi. Jika server menerima masukan yang sudah ditolak oleh klien, maka mungkin itu adalah indikasi dari sebuah serangan. Kedua, sisi-klien kesalahan-pengecekan dapat membantu memberikan umpan balik kepada pengguna tentang harapan untuk menginput yang valid. Ketiga, mungkin ada sebuah pengurangan pada waktu memproses sisi-server untuk kesalahan masukan yang tidak sengaja, walau ini biasanya adalah tabungan kecil.

Jangan bergantung secara khusus pada validasi daftar hitam untuk mendeteksi masukan berbahaya atau untuk mengkodekan hasil. Ada terlalu banyak hal untuk mengkodekan karakter yang sama, jadi kamu cenderung melewatkan beberapa varian.

Pada saat aplikasi anda mengkombinasikan data dari berbagai sumber, lakukan validasi setelah sumbernya dikombinasikan. Elemen data individual mungkin melewati tahap validasi tapi melanggar pembatasan yang dimaksudkan setelah dikombinasikan.

Asumsikan semua masukan itu berbahaya Gunakan strategi validasi masukan "accept known good", i.e., menggunakan daftar putih masukan yang dapat diterima yang sesuai dengan spesifikasi. Tolak masukan apa pun yang tidak sesuai dengan spesifikasi, atau ubah menjadi sesuatu yang tidak. Jangan mengandalkan secara eksklusif untuk mencari masukan jahat atau cacat (i.e., jangan mengandalkan daftar hitam). Namun, blacklist dapat berguna untuk mendeteksi potensi serangan atau menentukan input mana yang salah sehingga harus ditolak secara langsung.

Saat melakukan validasi masukan, pertimbangkan semua properti yang berpotensi relevan, termasuk panjang, jenis masukan, kisaran nilai yang dapat diterima, input yang hilang atau tambahan, sintaksis, konsistensi di bidang terkait, dan kesesuaian dengan peraturan bisnis. Sebagai contok dari logika aturan bisnis, "perahu" mungkin sintakstical valid karena itu hanya berisi karakter alfanumerik, tapi itu tidak valid jika kamu mengharapkan warna seperti "merah" atau "biru."

Tahap: Implementasi

Jadi berhati-hati untuk memvalidasi masukan anda pada saat kamu meminta kode yang melewati batas bahasa, seperti dari bahasa yang diartikan ke kode asli. Hal ini bisa menciptakan interaksi tak terduga antara batas bahasa. Pastikan bahwa Anda tidak melanggar salah satu ekspektasi bahasa yang Anda gunakan untuk berinteraksi. Sebagai contoh, meskipun Java mungkin tidak menjadi rentan terhadap penyangga melimpah, memberikan sebuah argumen besar dalam sebuah panggilan ke kode asli dapat memicu luapan.

Langsung ubah jenis masukan Anda ke tipe data yang diharapkan, seperti menggunakan fungsi konversi yang menerjemahkan string menjadi angka. Setelah beralih ke tipe data yang diharapkan, pastikan nilai masukan masuk dalam kisaran nilai yang diijinkan yang diharapkan dan konsistensi multi bidang dipertahankan.

Masukan harus diterjemahkan dan disinronkan ke representasi internal aplikasi saat ini sebelum divalidasi. Pastikan aplikasi Anda tidak sengaja memecahkan kode input yang sama dua kali. Kesalahan tersebut dapat digunakan untuk memotong skema daftar putih dengan memasukkan masukan berbahaya setelah diperiksa. Gunakan perpustakaan seperti OWASP ESAPI Canonicalization control.

Pertimbangkan untuk melakukan kanonisasi berulang sampai masukan Anda tidak berubah lagi. Ini akan menghindari decoding ganda dan skenario serupa, namun mungkin secara tidak sengaja memodifikasi masukan yang diizinkan mengandung konten berbahaya yang dikodekan dengan benar.

Saat bertukar data antar komponen, pastikan kedua komponen tersebut menggunakan pengkodean karakter yang sama. Pastikan pengkodean yang tepat diterapkan pada setiap antarmuka. Secara eksplisit tetapkan pengkodean yang Anda gunakan kapan pun protokol memungkinkan Anda melakukannya.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Anti otomatisasi yang tidak mencukupi</alert>
	<desc>Tidak cukup anti-otomatis terjadi pada saat aplikasi web mengizinkan seorang penyerang untuk mengotomatiskan sebuah proses yang semula dirancang untuk dilakukan hanya dengan cara manual, yaitu oleh seorang manusia pengguna web.

Fungsi aplikasi web yang sering menjadi sasaran serangan otomasi bisa meliputi:
    * Formulir login aplikasi - penyerang dapat mengotomatiskan permintaan masuk paksa dalam upaya menebak kredensial pengguna
    * Formulir pendaftaran layanan - penyerang dapat secara otomatis membuat ribuan akun baru
    * Formulir email - penyerang dapat memanfaatkan formulir email sebagai spam relay atau untuk membanjiri kotak pesan pengguna tertentu
    * Pemeliharaan akun - Penyerang dapat melakukan DoS massa terhadap sebuah aplikasi, dengan membanjiri dengan banyak permintaan untuk menonaktifkan atau menghapus akun pengguna
    * Formulir informasi akun - penyerang dapat melakukan upaya massal untuk mengumpulkan informasi pribadi pengguna dari aplikasi web
    * Formulir komentar / formulir pengajuan konten- ini bisa digunakan untuk blog spamming, forum web dan papan buletin web dengan mengirimkan konten secara otomatis seperti spam atau bahkan malware berbasis web.
    * Formulir yang terkait dengan query database SQL - ini dapat dieksploitasi untuk melakukan penolakan serangan layanan terhadap aplikasi. Serangan dilakukan dengan mengirimkan banyak query SQL berat dalam waktu singkat, sehingga menyangkal pengguna nyata dari layanan.
    Aplikasi eShopping / eCommerce - eShopping dan eCommerce yang tidak memberlakukan pembeli manusia saja, dapat dimanfaatkan untuk membeli barang pilihan dalam jumlah banyak, seperti tiket acara olahraga. Ini kemudian dijual oleh calo untuk harga yang lebih tinggi.
    * Jajak pendapat online - jajak pendapat dan jenis sistem pemungutan suara online lainnya dapat ditumbangkan secara otomatis dengan pilihan tertentu.
    * Pengiriman pesan SMS berbasis web dapat memanfaatkan sistem pengiriman pesan SMS untuk pengguna ponsel spam
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Penanganan Output yang Tidak Tepat</alert>
	<desc>Penanganan output mengacu pada bagaimana sebuah aplikasi menghasilkan data keluar.  Jika sebuah aplikasi memiliki penanganan output yang tidak tepat, data output dapat dikonsumsi yang mengarah ke kerentanan dan tindakan yang tidak pernah dimaksudkan oleh pengembang aplikasi.  Dalam banyak kasus, interpretasi yang tidak disengaja ini diklasifikasikan sebagai satu atau lebih bentuk kerentanan aplikasi kritis.

Setiap lokasi dimana data meninggalkan batas aplikasi mungkin tunduk pada penanganan output yang tidak benar.  Batas aplikasi ada dimana data meninggalkan satu konteks dan memasuki area yang lain.  Ini termasuk aplikasi yang mengirimkan data ke aplikasi lain melalui layanan web, soket, command line, variabel lingkungan, dll.  Ini juga mencakup data yang lewat antara tingkatan dalam arsitektur aplikasi, seperti database, server direktori, juru bahasa HTML / JavaScript (browser), atau sistem operasi.  Detail lebih lanjut tentang penanganan penanganan yang tidak tepat dapat terjadi dapat ditemukan pada bagian di bawah berjudul "Lokasi Output Data Umum".

Penanganan keluaran yang tidak tepat dapat mengambil berbagai bentuk dalam aplikasi.  Bentuk-bentuk ini dapat dikategorikan menjadi: kesalahan protokol, kesalahan aplikasi dan data kesalahan terkait konsumen.  Kesalahan protokol mencakup pengkodean keluaran yang hilang atau tidak semestinya atau keluar dan keluar dari data yang tidak valid.  Kesalahan aplikasi mencakup kesalahan logika seperti mengeluarkan data yang salah atau menyebarkan konten berbahaya tanpa filter.  Jika aplikasi tidak benar membedakan konten yang sah dari yang tidak sah, atau tidak mengatasi kerentanan yang diketahui di konsumen data, jika aplikasi tersebut menyebabkan penyalahgunaan data konsumen disebabkan oleh penanganan keluaran yang tidak benar.

Aplikasi yang tidak menyediakan data dalam konteks yang benar memungkinkan penyerang untuk menyalahgunakan data konsumen.  Hal ini dapat menyebabkan ancaman spesifik yang dirujuk dalam Klasifikasi Ancaman WASC, termasuk Spoofing Konten, Skrip Lintas Situs, Pemisahan Respons HTTP, Penyelesaian Respons HTTP, Injeksi LDAP, Pemberian Perintah, Detay Routing, Pelemahan Array Sabun, Redirector URL, Injeksi XML, XQuery Injection, XPath Injection, Mail Command Injection, Null Injection dan SQL Injection.

Penanganan keluaran yang tepat mencegah interpretasi data yang tidak diharapkan atau tidak disengaja oleh konsumen.  Untuk mencapai tujuan ini, pengembang harus memahami model data aplikasi, bagaimana data akan dikonsumsi oleh bagian aplikasi lainnya, dan bagaimana akhirnya dipresentasikan kepada pengguna.  Teknik untuk memastikan penanganan output yang tepat termasuk namun tidak terbatas pada penyaringan dan sanitasi data (lebih rinci tentang sanitasi dan penyaringan keluaran dapat ditemukan di bagian yang berjudul dengan tepat di bawah ini).  Namun, penggunaan teknik penanganan keluaran yang tidak konsisten dapat benar-benar meningkatkan risiko penanganan keluaran yang tidak tepat jika data keluaran diabaikan atau tidak diobati.  Untuk memastikan pengembang "pertahanan secara mendalam" harus mengasumsikan bahwa semua data dalam aplikasi tidak dipercaya saat memilih strategi penanganan keluaran yang sesuai.

Meskipun penanganan keluaran yang tepat mungkin memerlukan banyak bentuk, aplikasi tidak dapat diamankan kecuali jika proteksi terhadap interpretasi yang tidak diinginkan oleh konsumen data. Persyaratan inti ini sangat penting untuk sebuah aplikasi untuk menangani operasi keluaran dengan aman.</desc>
	<solution>Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.

Misalnya, pertimbangkan untuk menggunakan kontrol Encode ESAPI atau alat, perpustakaan, atau kerangka kerja serupa. Ini akan membantu programmer menyandikan output dengan cara yang kurang rentan terhadap kesalahan.

Sebagai alternatif, gunakan fungsi built-in, namun pertimbangkan untuk menggunakan pembungkus jika fungsi tersebut ditemukan memiliki kerentanan.

Jika tersedia, gunakan mekanisme terstruktur yang secara otomatis memberlakukan pemisahan antara data dan kode. Mekanisme ini mungkin dapat memberikan kutipan, pengkodean, dan validasi yang relevan secara otomatis, alih-alih mengandalkan pengembang untuk menyediakan kemampuan ini di setiap titik di mana output dihasilkan.

Sebagai contoh, prosedur yang tersimpan dapat menerapkan struktur query database dan mengurangi kemungkinan injeksi SQL.

Pahami konteks dimana data Anda akan digunakan dan pengkodean yang akan diharapkan. Hal ini sangat penting saat mentransmisikan data antar komponen yang berbeda, atau saat menghasilkan keluaran yang dapat berisi beberapa pengkodean sekaligus, seperti halaman web atau pesan email multi-bagian. Pelajari semua protokol komunikasi yang diharapkan dan representasi data untuk menentukan strategi pengkodean yang dibutuhkan.

Dalam beberapa kasus, validasi masukan mungkin merupakan strategi penting saat pengkodean keluaran bukan merupakan solusi yang lengkap. Misalnya, Anda mungkin menyediakan output yang sama yang akan diproses oleh banyak konsumen yang menggunakan pengkodean atau representasi yang berbeda. Dalam kasus lain, Anda mungkin diminta untuk mengizinkan masukan yang diberikan pengguna untuk berisi informasi kontrol, seperti tag HTML terbatas yang mendukung pemformatan di wiki atau papan buletin. Bila persyaratan jenis ini harus dipenuhi, gunakan daftar putih yang sangat ketat untuk membatasi rangkaian kontrol yang dapat digunakan. Verifikasi bahwa struktur sintaksis yang dihasilkan adalah apa yang Anda harapkan. Gunakan metode pengkodean normal Anda untuk sisa masukan.

Gunakan validasi masukan sebagai ukuran pertahanan-dalam-mendalam untuk mengurangi kemungkinan kesalahan penyandian keluaran (lihat CWE-20).

Saat bertukar data antar komponen, pastikan kedua komponen tersebut menggunakan pengkodean karakter yang sama. Pastikan pengkodean yang tepat diterapkan pada setiap antarmuka. Secara eksplisit tetapkan pengkodean yang Anda gunakan kapan pun protokol memungkinkan Anda melakukannya.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference></reference>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>Injeksi XML</alert>
	<desc>XML Injection adalah teknik serangan yang digunakan untuk memanipulasi atau mengkompromikan logika aplikasi atau layanan XML. Penyuntikan konten dan / atau struktur XML yang tidak diinginkan ke dalam pesan XML dapat mengubah logika niat aplikasi. Selanjutnya, injeksi XML dapat menyebabkan penyisipan konten berbahaya ke dalam pesan / dokumen yang dihasilkan.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference></reference>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>Permintaan HTTP Memisahkan</alert>
	<desc>HTTP Request Splitting adalah serangan yang memungkinkan pemaksaan mengirim permintaan HTTP yang sewenang-wenang, menimbulkan XSS dan meracuni cache browser. Inti dari serangan tersebut adalah kemampuan penyerang, begitu korban (browser) dipaksa memuat halaman HTML berbahaya penyerang, untuk memanipulasi salah satu fungsi browser untuk mengirim 2 permintaan HTTP alih-alih satu permintaan HTTP. Dua mekanisme seperti itu telah dieksploitasi sampai saat ini: objek XmlHttpRequest (XHR untuk jangka pendek) dan mekanisme otentikasi penggabungan HTTP. Agar serangan ini berhasil, browser harus menggunakan proxy HTTP depan (tidak semuanya mendukung "serangan ini), atau serangan harus dilakukan terhadap host yang berada pada IP yang sama (dari perspektif browser) dengan penyerang mesin.</desc>
	<solution>Hindari penggunaan CRLF sebagai urutan khusus.

Saring dengan tepat atau kutipan urutan CRLF pada input yang dikendalikan pengguna.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>Respon HTTP Memisahkan</alert>
	<desc>Dalam serangan HTTP Response Splitting, selalu ada 3 pihak (setidaknya) yang terlibat:
     * Web server, yang memiliki lubang keamanan yang memungkinkan HTTP Response Memisahkan
     * Target - entitas yang berinteraksi dengan server web mungkin atas nama penyerang. Biasanya ini adalah server cache forward / reverse proxy), atau browser (mungkin dengan cache browser).
    Penyerang - memulai serangan Inti dari Respon HTTP Memisahkan kemampuan penyerang untuk mengirim permintaan HTTP tunggal yang memaksa server web membentuk arus keluaran, yang kemudian ditafsirkan oleh target sebagai dua tanggapan HTTP, bukan satu tanggapan, dalam kasus normal Respons pertama mungkin sebagian dikendalikan oleh penyerang, tapi ini kurang penting. Apa materi adalah bahwa penyerang benar-benar mengendalikan bentuk respons kedua dari baris status HTTP ke byte terakhir dari badan respons HTTP. Setelah ini mungkin, penyerang menyadari serangan tersebut dengan mengirimkan dua permintaan melalui target. Yang pertama memanggil dua tanggapan dari server web, dan permintaan kedua biasanya ditujukan pada beberapa sumber daya "innocent" di server web. Namun, permintaan kedua akan disesuaikan, sesuai target, dengan respons HTTP kedua, yang sepenuhnya dikendalikan oleh penyerang. Penyerang, oleh karena itu, menebak sasaran agar percaya bahwa sumber daya tertentu pada server web (yang ditunjuk oleh permintaan kedua) adalah respons HTTP server (konten server), padahal sebenarnya ada beberapa data, yang dipalsukan oleh penyerang melalui web server - ini adalah respon kedua.

Respon HTTP Serangan pemisah terjadi di mana skrip server menyematkan data pengguna di header tanggapan HTTP. Ini biasanya terjadi saat skrip menyematkan data pengguna di URL pengalihan respons pengalihan (kode status HTTP 3xx), atau saat skrip menyematkan data pengguna dalam nilai atau nama kuki saat respons tersebut menetapkan kuki.</desc>
	<solution>Buatlah header HTTP dengan sangat hati-hati, hindari penggunaan data masukan yang tidak divalidasi.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>Permintaan HTTP Penyelundupan</alert>
	<desc>Permintaan HTTP Penyelundupan adalah teknik serangan yang menyalahi ketidaksesuaian dalam penguraian permintaan HTTP yang tidak sesuai RFC antara dua perangkat HTTP (biasanya proxy front-end atau firewall dengan dukungan HTTP dan server web back-end) untuk menyelundupkan permintaan ke yang kedua. perangkat "melalui" perangkat pertama. Teknik ini memungkinkan penyerang mengirimkan satu set permintaan ke perangkat kedua sementara perangkat pertama melihat serangkaian permintaan yang berbeda. Pada gilirannya, ini memfasilitasi beberapa kemungkinan eksploitasi, seperti keracunan cache parsial, melewati perlindungan firewall dan XSS.</desc>
	<solution>Gunakan server web yang menggunakan prosedur penguraian HTTP yang ketat, seperti Apache (lihat referensi kertas).

Gunakan hanya komunikasi SSL.

Hentikan sesi klien setelah setiap permintaan.

Balikkan semua halaman menjadi non-cacheable.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>Penyelundupan Respons HTTP</alert>
	<desc>Penyelundupan respons HTTP adalah teknik untuk "menyelundupkan" 2 tanggapan HTTP dari server ke klien, melalui perangkat HTTP perantara yang mengharapkan (atau mengizinkan) satu tanggapan dari server.

Salah satu yang digunakan untuk teknik ini adalah untuk meningkatkan teknik pemecahan respons HTTP dasar agar bisa menghindari tindakan pemisahan respon anti-HTTP. Dalam kasus ini, perantara adalah mekanisme pemisahan respon anti-HTTP antara server web dan server proxy (atau browser web). Kasus penggunaan lainnya adalah untuk meniru tanggapan yang diterima oleh browser. Dalam hal ini, situs web jahat menyajikan browser pada halaman yang akan ditafsirkan browser karena berasal dari domain (target) yang berbeda. Penyelundupan respon HTTP dapat digunakan untuk mencapainya saat browser menggunakan server proxy untuk mengakses kedua situs.

Penyelundupan respon HTTP menggunakan teknik penyandian permintaan HTTP - seperti teknik untuk mengeksploitasi perbedaan antara mekanisme Pemisahan Respon HTTP (atau server proxy) yang akan dianggap sebagai aliran respon HTTP, dan aliran respons yang diurai oleh server proxy (atau browser). Jadi, sementara mekanisme pemisahan respons anti-HTTP dapat mempertimbangkan respons respons tertentu yang tidak berbahaya (respons HTTP tunggal), proxy / browser mungkin masih mengurainya sebagai dua respons HTTP, dan karenanya rentan terhadap semua hasil pemisahan respons HTTP asli. teknik (dalam kasus penggunaan pertama) atau rentan terhadap spoofing halaman (dalam kasus kedua). Sebagai contoh, beberapa mekanisme pemisahan respons anti-HTTP yang digunakan oleh beberapa mesin aplikasi melarang aplikasi memasukkan header yang berisi CR + LF ke respon. Namun penyerang dapat memaksa aplikasi memasukkan header yang berisi CR, sehingga menghindari mekanisme pertahanan. Namun penyerang dapat memaksa aplikasi memasukkan header yang berisi CR, sehingga menghindari mekanisme pertahanan.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference></reference>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Null Byte Injection</alert>
	<desc>Null Byte Injection adalah teknik penggunaan aktif yang digunakan untuk memotong filter pemeriksaan kewaspadaan di infrastruktur web dengan menambahkan karakter byte null yang dikodekan URL (seperti %00, atau 0x00 in hex) ke data yang disediakan pengguna.
 . Proses injeksi ini dapat mengubah logika aplikasi yang dimaksud dan memungkinkan musuh jahat mendapatkan akses tidak sah ke fail sistem.

Sebagian besar aplikasi web saat ini dikembangkan dengan menggunakan bahasa tingkat tinggi seperti, PHP, ASP, Perl, dan Java.
 . Namun, aplikasi web ini dalam beberapa kasus memerlukan pemrosesan kode tingkat tinggi pada tingkat sistem dan proses ini biasanya dilakukan dengan menggunakan fungsi 'C/C++'. Sifat beragam dari teknologi dependen ini telah menyebabkan kelas serangan yang disebut 'Null Byte Injection' atau 'Null Byte Poisoning'. Dalam C/C++, byte null mewakili string termination point atau delimiter character yang berarti berhenti memproses string dengan segera. Byte berikut pembatas akan diabaikan. Jika string kehilangan karakter nullnya, panjang string menjadi tidak diketahui sampai pointer memori terjadi untuk memenuhi nol byte berikutnya. Ramifikasi yang tidak disengaja ini dapat menyebabkan perilaku yang tidak biasa dan mengenalkan kerentanan di dalam lingkup sistem atau aplikasi. Dengan kata lain, beberapa bahasa tingkat tinggi memperlakukan 'null byte' sebagai placeholder untuk panjang string karena tidak memiliki arti khusus dalam konteksnya. Karena perbedaan penafsiran ini, null byte dapat dengan mudah disuntikkan untuk memanipulasi perilaku aplikasi.

URLs dibatasi untuk satu set karakter US-ASCII mulai dari 0x20 sampai 0x7E (hex) atau 32 sampai 126 (desimal). Namun, rentang yang disebutkan di atas menggunakan beberapa karakter yang tidak diizinkan karena memiliki arti khusus dalam konteks protokol HTTP. Untuk alasan ini, skema pengkodean URL diperkenalkan untuk menyertakan karakter khusus dalam URL menggunakan representasi karakter ASCII yang diperluas. Dalam hal "null byte", ini direpresentasikan sebagai %00 dalam heksadesimal. Lingkup serangan null byte dimulai saat aplikasi web berinteraksi dengan rutinitas 'C' aktif dan API eksternal dari OS yang mendasarinya. Dengan demikian, memungkinkan penyerang untuk memanipulasi sumber web dengan membaca atau menulis file berdasarkan hak pengguna aplikasi.</desc>
	<solution>Pengembang harus mengantisipasi bahwa karakter null atau byte nol akan disuntikkan/dihapus/dimanipulasi pada vektor masukan dari sistem perangkat lunak mereka. Gunakan kombinasi daftar hitam dan daftar putih yang sesuai untuk memastikan hanya input yang valid, yang diharapkan dan tepat yang diproses oleh sistem.

Asumsikan semua masukan itu berbahaya Gunakan mekanisme validasi masukan standar untuk memvalidasi semua masukan untuk aturan panjang, jenis, sintaks, dan bisnis sebelum menerima data yang akan ditampilkan atau disimpan. Gunakan "accept known good" strategi validasi.

Gunakan dan tentukan pengkodean keluaran yang kuat (seperti ISO 8859-1 atau UTF 8).

Jangan bergantung secara khusus pada validasi daftar hitam untuk mendeteksi masukan berbahaya atau untuk mengkodekan hasil. Ada terlalu banyak varian untuk mengkodekan karakter; Anda cenderung melewatkan beberapa varian.

Masukan harus diterjemahkan dan disinronkan ke representasi internal aplikasi saat ini sebelum divalidasi. Pastikan aplikasi Anda tidak memecahkan kode input yang sama dua kali. Kesalahan tersebut dapat digunakan untuk memotong skema daftar putih dengan memasukkan masukan berbahaya setelah diperiksa.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>Injeksi LDAP</alert>
	<desc>LDAP Injection adalah teknik serangan yang digunakan untuk mengeksploitasi situs web yang menyusun pernyataan LDAP dari masukan yang diberikan pengguna.

Lightweight Directory Access Protocol (LDAP) adalah protokol standar terbuka untuk mengecek dan memanipulasi layanan direktori X.500. Protokol LDAP berjalan pada protokol transportasi Internet, seperti TCP.
  Aplikasi web dapat menggunakan masukan yang diberikan oleh pengguna untuk membuat pemakluman LDAP khusus untuk permintaan halaman web dinamis.

Ketika aplikasi web gagal untuk membersihkan masukan yang diberikan oleh pengguna secara tepat, penyerang bisa saja mengubah konstruksi pemakluman LDAP. Ketika penyerang mampu memodifikasi pemakluman LDAP, proses akan berjalan dengan hak akses yang sama dengan komponen yang menjalankan perintah. (misalnya peladen berbasis data, peladen aplikasi Web, peladen Web, dll.). Hal ini dapat menyebabkan masalah keamanan serius dimana hak akses memberikan hak untuk mengecek, melakukan modifikasi atau menghapus apapun di dalam pohon LDAP. Teknik eksploitasi lanjutan yang sama yang tersedia pada SQL Injection juga dapat diterapkan dengan cara yang sama pada LDAP Injection.</desc>
	<solution>Asumsikan semua masukan itu berbahaya Gunakan kombinasi daftar hitam dan daftar putih yang sesuai untuk menetralkan sintaks LDAP dari input yang dikendalikan pengguna.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Surat Perintah Injeksi</alert>
	<desc>Surat Perintah Injeksi adalah teknik serangan yang digunakan untuk mengeksploitasi peladen surel dan aplikasi email web yang membuat pernyataan IMAP/SMTP dari masukan yang diberikan pengguna yang tidak disterilkan dengan benar. Kita bisa menjumpai dua jenis suntikan yaitu injeksi IMAP dan SMTP, tergantung pada jenis pemakluman yang dimanfaatkan oleh penyerang. Injeksi IMAP/SMTP memungkinkan untuk mengakses peladen surel yang sebelumnya tidak bisa kita akses. Dalam beberapa kasus, sistem internal ini tidak memiliki tingkat infrastruktur pengamanan yang sama seperti yang diterapkan pada kebanyakan peladen web front-end. Karenanya, penyerang bisa mendapati bahwa peladen surel memberikan hasil yang lebih baik dalam hal eksploitasi.
 . Di sisi lain, teknik ini bisa digunakan untuk menghindari batasan-batasan yang mungkin ada pada tingkat aplikasi (CAPTCHA, jumlah permintaan maksimum, dll.).</desc>
	<solution>Pahami semua area potensial di mana input yang tidak bisa dipercaya bisa masuk ke perangkat lunak Anda: parameter atau argumen, kuki, apapun yang bisa dibaca dari jaringan, variabel lingkungan, header permintaan serta konten, komponen URL, surel, fail, basis data, dan sistem eksternal lainnya. yang menyediakan data ke aplikasi. Lakukan validasi masukan pada antarmuka yang terdefinisi dengan baik.

Asumsikan semua masukan itu berbahaya Gunakan strategi validasi masukan "menerima dikenal baik" (yaitu menggunakan daftar putih). Tolak masukan apa pun yang tidak sesuai dengan spesifikasi, atau ubah menjadi sesuatu yang tidak. Gunakan daftar hitam untuk menolak masukan tak terduga dan mendeteksi potensi serangan.

Jangan bergantung secara khusus pada validasi daftar hitam untuk mendeteksi masukan berbahaya atau untuk mengkodekan hasil. Ada terlalu banyak hal untuk mengkodekan karakter yang sama, jadi kamu cenderung melewatkan beberapa varian.

Langsung ubah jenis masukan Anda ke tipe data yang diharapkan, seperti menggunakan fungsi konversi yang menerjemahkan string menjadi angka. Setelah beralih ke tipe data yang diharapkan, pastikan nilai masukan masuk dalam kisaran nilai yang diijinkan yang diharapkan dan konsistensi multi bidang dipertahankan.

Masukan harus diterjemahkan dan disinronkan ke representasi internal aplikasi saat ini sebelum divalidasi. Pastikan aplikasi Anda tidak sengaja memecahkan kode input yang sama dua kali . Kesalahan tersebut dapat digunakan untuk memotong skema daftar putih dengan memasukkan masukan berbahaya setelah diperiksa. Gunakan perpustakaan seperti OWASP ESAPI Canonicalization control.

Pertimbangkan untuk melakukan kanonisasi berulang sampai masukan Anda tidak berubah lagi. Ini akan menghindari decoding ganda dan skenario serupa, namun mungkin secara tidak sengaja memodifikasi masukan yang diizinkan mengandung konten berbahaya yang dikodekan dengan benar.

Saat bertukar data antar komponen, pastikan kedua komponen tersebut menggunakan pengkodean karakter yang sama. Pastikan pengkodean yang tepat diterapkan pada setiap antarmuka. Secara eksplisit tetapkan pengkodean yang Anda gunakan kapan pun protokol memungkinkan Anda melakukannya.

Pada saat aplikasi anda mengkombinasikan data dari berbagai sumber, lakukan validasi setelah sumbernya dikombinasikan. Elemen data individual mungkin melewati tahap validasi tapi melanggar pembatasan yang dimaksudkan setelah dikombinasikan.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>Perintah OS</alert>
	<desc>OS Commanding adalah teknik serangan yang digunakan untuk eksekusi perintah sistem operasi yang tidak sah.

OS Commanding adalah hasil langsung dari pencampuran kode terpercaya dan data yang tidak tepercaya. Serangan ini dimungkinkan saat aplikasi menerima masukan yang tidak tepercaya untuk membangun perintah sistem operasi dengan cara yang tidak aman yang melibatkan sanitasi data yang tidak benar, dan/atau pemanggilan program eksternal yang tidak tepat. Di OS Commanding, perintah yang dieksekusi oleh penyerang akan dijalankan dengan hak istimewa komponen yang sama dengan yang mengeksekusi perintah, (misalnya server database, server aplikasi web, server web, pembungkus, aplikasi). Karena perintah dieksekusi di bawah hak istimewa komponen pelaksana, penyerang dapat memanfaatkan ini untuk mendapatkan akses atau kerusakan komponen yang tidak dapat dijangkau (misalnya direktori dan file sistem operasi).</desc>
	<solution>Jika memungkinkan, gunakan panggilan perpustakaan daripada proses eksternal untuk menciptakan fungsi yang diinginkan.

Jalankan kode Anda di "penjara" atau lingkungan kotak pasir serupa yang memberlakukan batasan ketat antara proses dan sistem operasi. Ini dapat secara efektif membatasi file mana yang dapat diakses di direktori tertentu atau perintah mana yang dapat dijalankan oleh perangkat lunak Anda.

Contoh tingkat-OS termasuk penjara chroot Unix, AppArmor, dan SELinux. Secara umum, kode yang dikelola mungkin memberikan beberapa perlindungan. Sebagai contoh, java.io.FilePermission di Java SecurityManager memungkinkan Anda untuk menentukan pembatasan pada operasi file.
Ini mungkin bukan solusi yang layak, dan ini hanya membatasi dampaknya terhadap sistem operasi; sisa aplikasi Anda mungkin masih bisa dikompromikan.

Untuk data yang akan digunakan untuk menghasilkan perintah yang akan dijalankan, simpan sebanyak mungkin data dari kontrol eksternal. Misalnya, dalam aplikasi web, ini mungkin memerlukan penyimpanan perintah secara lokal di negara sesi alih-alih mengirimkannya ke klien di bidang formulir tersembunyi.

Gunakan perpustakaan atau kerangka kerja yang disahkan yang tidak memungkinkan kelemahan ini terjadi atau menyediakan konstruksi yang membuat kelemahan ini lebih mudah dihindari.

Misalnya, pertimbangkan untuk menggunakan kontrol Encode ESAPI atau alat, perpustakaan, atau kerangka kerja serupa. Ini akan membantu programmer menyandikan output dengan cara yang kurang rentan terhadap kesalahan.

Jika Anda perlu menggunakan string kueri atau perintah kueri yang dihasilkan secara dinamis terlepas dari risikonya, cukup kutip argumen dan lepaskan karakter khusus apa pun dalam argumen tersebut. Pendekatan yang paling konservatif adalah melarikan diri atau menyaring semua karakter yang tidak melewati daftar putih yang sangat ketat (seperti segala sesuatu yang bukan spasial atau spasi putih). Jika beberapa karakter khusus masih dibutuhkan, seperti white space, bungkus setiap argumen dalam tanda kutip setelah langkah escape/filtering. Hati-hati dengan injeksi argumen.

Jika program yang akan dijalankan memungkinkan argumen yang akan ditentukan dalam file masukan atau dari input standar, pertimbangkan untuk menggunakan mode tersebut untuk meneruskan argumen alih-alih baris perintah.

Jika tersedia, gunakan mekanisme terstruktur yang secara otomatis memberlakukan pemisahan antara data dan kode. Mekanisme ini mungkin dapat memberikan kutipan, pengkodean, dan validasi yang relevan secara otomatis, alih-alih mengandalkan pengembang untuk menyediakan kemampuan ini di setiap titik di mana output dihasilkan.

Beberapa bahasa menawarkan beberapa fungsi yang dapat digunakan untuk memanggil perintah. Bila memungkinkan, identifikasikan fungsi apa pun yang memanggil shell perintah dengan menggunakan string tunggal, dan gantilah dengan fungsi yang memerlukan argumen individual. Fungsi ini biasanya melakukan pemanggilan dan penyaringan argumen yang sesuai. Sebagai contoh, di C, fungsi sistem() menerima sebuah string yang berisi seluruh perintah yang akan dieksekusi, sedangkan execl(), execve(), dan yang lainnya memerlukan sebuah array string, satu untuk setiap argumen. Pada Windows, CreateProcess() hanya menerima satu perintah pada satu waktu. Di Perl, jika sistem() dilengkapi dengan serangkaian argumen, maka akan mengutip masing-masing argumen.

Asumsikan semua masukan itu berbahaya Gunakan strategi validasi masukan "accept known good", i.e., menggunakan daftar putih masukan yang dapat diterima yang sesuai dengan spesifikasi. Tolak masukan apa pun yang tidak sesuai dengan spesifikasi, atau ubah menjadi sesuatu yang tidak. Jangan mengandalkan secara eksklusif untuk mencari masukan jahat atau cacat (i.e., jangan mengandalkan daftar hitam). Namun, blacklist dapat berguna untuk mendeteksi potensi serangan atau menentukan input mana yang salah sehingga harus ditolak secara langsung.

Saat melakukan validasi masukan, pertimbangkan semua properti yang berpotensi relevan, termasuk panjang, jenis masukan, kisaran nilai yang dapat diterima, input yang hilang atau tambahan, sintaksis, konsistensi di bidang terkait, dan kesesuaian dengan peraturan bisnis. Sebagai contoh logika aturan bisnis, "kapal" mungkin sintaksis karena hanya berisi karakter alfanumerik, namun tidak berlaku jika Anda mengharapkan warna seperti "merah" atau "biru".

Saat membuat string perintah OS, gunakan whitelist ketat yang membatasi set karakter berdasarkan nilai parameter yang diharapkan dalam permintaan. Ini secara tidak langsung akan membatasi lingkup serangan, namun teknik ini kurang penting daripada pengkodean output yang tepat dan melarikan diri.

Perhatikan bahwa pengkodean output yang tepat, escape, dan quoting adalah solusi yang paling efektif untuk mencegah injeksi perintah OS, walaupun validasi masukan mungkin memberikan beberapa pertahanan yang mendalam. Hal ini karena secara efektif membatasi apa yang akan muncul dalam output. Validasi masukan tidak akan selalu mencegah injeksi perintah OS, terutama jika Anda diminta untuk mendukung bidang teks dengan bentuk bebas yang bisa mengandung karakter yang sewenang-wenang. Misalnya, saat meminta program surat, Anda mungkin perlu membiarkan bidang subjek berisi masukan berbahaya lainnya seperti ";" dan ">" karakter, yang perlu diloloskan atau ditangani. Dalam kasus ini, pengupasan karakter bisa mengurangi risiko injeksi perintah OS, namun akan menghasilkan perilaku yang salah karena bidang subjek tidak akan dicatat sesuai keinginan pengguna. Kelihatannya itu adalah ketidaknyamanan kecil, tapi bisa jadi lebih penting bila program bergantung pada garis subjek yang terstruktur dengan baik agar bisa menyampaikan pesan ke komponen lain.

Bahkan jika Anda membuat kesalahan dalam validasi Anda (seperti melupakan satu dari 100 bidang masukan), pengkodean yang sesuai kemungkinan besar akan melindungi Anda dari serangan berbasis injeksi. Selama tidak dilakukan secara terpisah, validasi masukan masih merupakan teknik yang berguna, karena dapat mengurangi permukaan serangan Anda secara signifikan, memungkinkan Anda untuk mendeteksi beberapa serangan, dan memberikan manfaat keamanan lainnya yang tidak dapat ditangani oleh pengkodean yang tepat.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Routing Detour</alert>
	<desc>WS-Routing Protocol (WS-Routing) adalah protokol untuk menukar pesan SOAP dari pengirim pesan awal ke penerima utama, biasanya melalui satu set perantara. Protokol WS-Routing diimplementasikan sebagai ekstensi SOAP, dan disematkan di Header SOAP. WS-Routing sering digunakan untuk menyediakan cara mengarahkan lalu lintas XML melalui lingkungan dan transaksi yang kompleks dengan mengizinkan stasiun jalan sementara di jalur XML untuk menetapkan petunjuk routing ke dokumen XML.

Routing Detours adalah tipe dari "Manusia di Tengah" serangan dimana Perantara bisa disuntikkan atau "dibajak" untuk mengarahkan pesan sensitif ke lokasi di luar. Informasi routing (baik di header HTTP atau header WS-Routing) dapat dimodifikasi dalam perjalanan dan jejak routing dapat dihapus dari header dan pesan sehingga aplikasi penerima tidak ada yang lebih bijak yang telah dilakukan jalan memutar routing. Header dan penyisipan objek header seringkali kurang terlindungi dari pada pesan; Hal ini disebabkan oleh fakta bahwa header digunakan sebagai tangkapan semua untuk metadata tentang transaksi seperti otentikasi, perutean, pemformatan, skema, kanonisasi, ruang nama, dll. Selain itu, banyak proses mungkin terlibat dalam menambahkan/memproses header dokumen XML. Dalam banyak implementasi info routing bisa berasal dari layanan web eksternal (menggunakan WS-Referral misalnya) yang menyediakan routing spesifik untuk transaksi tersebut.

WS-Addressing adalah standar yang lebih baru yang diterbitkan oleh W3C untuk menyediakan fungsionalitas perutean ke pesan SOAP. Salah satu perbedaan utama antara WS-Routing dan WS-Addressing adalah bahwa WS-Addressing hanya menyediakan lokasi berikutnya dalam rute. Sementara sedikit penelitian telah dilakukan terhadap kerentanan WS-Addressing to Routing Detour Attack, setidaknya satu makalah (lihat referensi #6 di bawah) menunjukkan bahwa WS-Addressing rentan terhadap Jalan memutar rute juga.</desc>
	<solution>Selalu mengotentikasi kedua ujung saluran komunikasi secara penuh.

Patuhi prinsip mediasi yang lengkap.

Sertifikat mengikat identitas ke kunci kriptografi untuk mengotentikasi pihak yang berkomunikasi. Seringkali, sertifikat tersebut mengambil bentuk hash hash yang dienkripsi dari identitas subjek, kunci publik, dan informasi seperti waktu penerbitan atau kedaluwarsa menggunakan kunci privat emiten. Sertifikat dapat divalidasi dengan mengartikan sertifikat dengan kunci publik emiten. Lihat juga rantai tanda tangan sertifikat X.509 dan struktur sertifikasi PGP.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Jalur Traversal</alert>
	<desc>Teknik serangan Path Traversal memungkinkan penyerang mengakses file, direktori, dan perintah yang berpotensi berada di luar direktori root dokumen web. Penyerang dapat memanipulasi URL sedemikian rupa sehingga situs web akan mengeksekusi atau mengungkapkan isi file sewenang-wenang di manapun pada server web. Perangkat yang menampilkan antarmuka berbasis HTTP berpotensi rentan terhadap Path Traversal.

Sebagian besar situs web membatasi akses pengguna ke bagian tertentu dari sistem file, biasanya disebut "web document root" atau "CGI root" direktori. Direktori ini berisi file yang ditujukan untuk akses pengguna dan executable yang diperlukan untuk mendorong fungsionalitas aplikasi web. Untuk mengakses file atau mengeksekusi perintah di mana saja pada sistem file, jalan Traversal serangan akan memanfaatkan kemampuan urutan karakter khusus.

Serangan Traversal Path yang paling dasar menggunakan "../" urutan karakter spesial untuk mengubah lokasi sumber daya yang diminta di URL. Meskipun server web yang paling populer akan mencegah teknik ini untuk melepaskan akar dokumen web, penyandian alternatif dari urutan "../" dapat membantu melewati filter keamanan. Variasi metode ini termasuk pengkodean Unicode yang valid dan tidak valid ("..%u2216" atau "..%c0%af") dari karakter garis miring ke depan, karakter garis miring terbalik (".. \") pada server berbasis Windows, URL yang dikodekan karakter "%2e%2e%2f"), dan pengkodean URL ganda ("..%255c") dari karakter garis miring terbalik.

Bahkan jika server web benar-benar membatasi jalan yang ditempuh Traversal di jalur URL, aplikasi web itu sendiri mungkin masih rentan karena penanganan input pengguna yang tidak tepat. Ini adalah masalah umum aplikasi web yang menggunakan mekanisme template atau memuat teks statis dari file. Dalam variasi serangan, nilai parameter URL asli diganti dengan nama file dari salah satu skrip dinamis aplikasi web. Ternyata bisa mengungkap sumber kode karena file tersebut ditafsirkan sebagai teks dan bukan script yang bisa dieksekusi. Teknik ini sering menggunakan karakter khusus tambahan seperti titik (".") Untuk mengungkapkan daftar direktori kerja saat ini, atau "%00" karakter NULL untuk melewati pemeriksaan ekstensi file yang belum sempurna.</desc>
	<solution>Asumsikan semua masukan itu berbahaya Gunakan strategi validasi masukan "accept known good", i.e., menggunakan daftar putih masukan yang dapat diterima yang sesuai dengan spesifikasi. Tolak masukan apa pun yang tidak sesuai dengan spesifikasi, atau ubah menjadi sesuatu yang tidak. Jangan mengandalkan secara eksklusif untuk mencari masukan jahat atau cacat (i.e., jangan mengandalkan daftar hitam). Namun, blacklist dapat berguna untuk mendeteksi potensi serangan atau menentukan input mana yang salah sehingga harus ditolak secara langsung.

Saat melakukan validasi masukan, pertimbangkan semua properti yang berpotensi relevan, termasuk panjang, jenis masukan, kisaran nilai yang dapat diterima, input yang hilang atau tambahan, sintaksis, konsistensi di bidang terkait, dan kesesuaian dengan peraturan bisnis. Sebagai contoh logika aturan bisnis, "kapal" mungkin sintaksis karena hanya berisi karakter alfanumerik, namun tidak berlaku jika Anda mengharapkan warna seperti "merah" atau "biru."

Untuk nama file, gunakan whitelist ketat yang membatasi karakter yang akan digunakan. Jika memungkinkan, biarkan saja satu "." karakter dalam nama file untuk menghindari kelemahan, dan mengecualikan pemisah direktori seperti "/". Gunakan daftar putih ekstensi file yang diijinkan.

Peringatan: Jika Anda mencoba untuk membersihkan data Anda, maka lakukanlah agar hasil akhirnya tidak dalam bentuk yang bisa berbahaya. Mekanisme sanitasi dapat menghapus karakter seperti '.' dan ';' yang mungkin diperlukan untuk beberapa eksploitasi. Penyerang bisa mencoba mengelabui mekanisme sanitasi menjadi "membersihkan" data menjadi bentuk yang berbahaya. Misalkan penyerang menyuntikkan '.' di dalam nama file (misalnya "sensi.tiveFile") dan mekanisme sanitasi menghapus karakter yang menghasilkan nama file yang valid, "sensitiveFile". Jika data masukan sekarang diasumsikan aman, maka file tersebut dapat dikompromikan. 

Masukan harus diterjemahkan dan disinronkan ke representasi internal aplikasi saat ini sebelum divalidasi. Pastikan aplikasi Anda tidak memecahkan kode input yang sama dua kali. Kesalahan tersebut dapat digunakan untuk memotong skema daftar putih dengan memasukkan masukan berbahaya setelah diperiksa.

Gunakan fungsi kanonisasi jalur intern (seperti realpath() di C) yang menghasilkan versi kanonik dari nama jalan, yang secara efektif menghilangkan urutan ".." dan tautan simbolis.

Jalankan kode Anda dengan menggunakan hak istimewa terendah yang diperlukan untuk menyelesaikan tugas yang diperlukan. Jika memungkinkan, buat akun terisolasi dengan hak istimewa terbatas yang hanya digunakan untuk satu tugas tunggal. Dengan begitu, serangan yang berhasil tidak akan segera memberi penyerang akses ke perangkat lunak atau lingkungan lainnya. Sebagai contoh, aplikasi database jarang perlu dijalankan sebagai administrator database, terutama dalam operasi sehari-hari.

Bila kumpulan objek yang dapat diterima, seperti nama file atau URLs, terbatas atau diketahui, buat pemetaan dari seperangkat nilai masukan tetap (seperti ID numerik) ke nama file atau URL yang sebenarnya, dan tolak semua masukan lainnya.

Jalankan kode Anda di "penjara" atau lingkungan kotak pasir serupa yang memberlakukan batasan ketat antara proses dan sistem operasi. Ini dapat secara efektif membatasi file mana yang dapat diakses di direktori tertentu atau perintah mana yang dapat dijalankan oleh perangkat lunak Anda.

Contoh tingkat-OS termasuk penjara chroot Unix, AppArmor, dan SELinux. Secara umum, kode yang dikelola mungkin memberikan beberapa perlindungan. Sebagai contoh, java.io.FilePermission di Java SecurityManager memungkinkan Anda untuk menentukan pembatasan pada operasi file.

Ini mungkin bukan solusi yang layak, dan ini hanya membatasi dampaknya terhadap sistem operasi; sisa aplikasi Anda mungkin masih bisa dikompromikan.
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Lokasi Sumber Daya yang Dapat Diprediksi</alert>
	<desc>Lokasi Sumber Daya yang Dapat Diprediksi adalah teknik serangan yang digunakan untuk menemukan konten dan fungsi situs web tersembunyi. Dengan membuat tebakan terdidik melalui penyerang yang kasar bisa menebak nama file dan direktori yang tidak ditujukan untuk tampilan publik. Kasar memaksa nama file itu mudah karena file/path sering memiliki konvensi penamaan yang umum dan berada di lokasi standar. Ini dapat mencakup file sementara, file cadangan, log, bagian situs administratif, file konfigurasi, aplikasi demo, dan file sampel. File-file ini dapat mengungkapkan informasi sensitif tentang situs jaringan, aplikasi jaringan internal, informasi basis data, kata sandi, nama mesin, jalur file ke area sensitif lainnya, dll...

Ini tidak hanya membantu mengidentifikasi permukaan situs yang dapat menyebabkan kerentanan situs tambahan, namun juga dapat mengungkapkan informasi berharga kepada penyerang tentang lingkungan atau penggunanya. Lokasi Sumber Daya yang Dapat Diprediksi juga dikenal sebagai Penjelajahan Paksa, Penjelajahan Paksa, Pencacahan Berkas, dan Pencacahan Direktori.</desc>
	<solution>Terapkan otorisasi kontrol akses yang sesuai untuk setiap akses ke semua URL, skrip atau mengajukan yang dibatasi.

Pertimbangkan untuk menggunakan kerangka berbasis MVC seperti Topangan.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP Array Abuse</alert>
	<desc>XML SOAP array adalah target umum untuk penyalahgunaan. Susunan SOAP didefinisikan sebagai memiliki tipe "SOAP-ENC:Array" atau tipe yang berasal dari sana. Array SOAP memiliki satu atau lebih dimensi (rank) yang anggotanya dibedakan dengan posisi urut. Nilai array direpresentasikan sebagai serangkaian elemen yang mencerminkan array, dengan anggota muncul dalam urutan urut naik. Untuk banyak dimensi Array dimensi di sisi kanan bervariasi paling cepat. Setiap elemen anggota dinobatkan sebagai elemen independen. Sebuah layanan web yang mengharapkan sebuah array dapat menjadi sasaran serangan XML DoS dengan memaksa server SOAP untuk membangun array besar dalam memori mesin, sehingga menimbulkan kondisi DoS pada mesin karena pra-alokasi memori.</desc>
	<solution> Lakukan validasi input yang cukup terhadap nilai yang mempengaruhi jumlah memori yang dialokasikan. Tentukan strategi yang tepat untuk menangani permintaan yang melebihi batas, dan pertimbangkan untuk mendukung opsi konfigurasi sehingga administrator dapat memperpanjang jumlah memori yang akan digunakan jika diperlukan.

Jalankan program Anda menggunakan batas sumber daya yang disediakan sistem untuk memori. Ini mungkin masih menyebabkan program mogok atau keluar, tapi dampaknya terhadap sistem lainnya akan diminimalkan.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abus</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>Injeksi SSL</alert>
	<desc>Injeksi SSI (Server-side Include) adalah teknik mengeksploitasi sisi server yang memungkinkan penyerang mengirim kode ke aplikasi web, yang kemudian akan dieksekusi secara lokal oleh server web. Injeksi SSI mengeksploitasi kegagalan aplikasi web untuk membersihkan data yang dipasok pengguna sebelum dimasukkan ke file HTML sisi server yang diinterpretasikan.

Sebelum melayani halaman HTML web, web server dapat mengurai dan mengeksekusi pernyataan penyertaan sisi Server sebelum memberikan kepada klien. Dalam beberapa kasus (misalnya papan pesan, buku tamu, atau sistem pengelolaan konten), aplikasi web akan menyisipkan data yang dipasok pengguna ke dalam sumber halaman web.

Jika penyerang mengajukan pernyataan Sertakan Server-sisi, dia mungkin memiliki kemampuan untuk menjalankan perintah sistem operasi yang sewenang-wenang, atau menyertakan konten file yang dibatasi pada saat halaman disajikan. Hal ini dilakukan pada tingkat izin pengguna server web.</desc>
	<solution>Nonaktifkan eksekusi SSI pada halaman yang tidak memerlukannya. Untuk halaman yang membutuhkan SSI pastikan Anda melakukan pengecekan berikut
- Saja aktifkan perintah SSI yang dibutuhkan untuk halaman ini dan nonaktifkan semua yang lain.
- Entitas HTML menyandikan data yang dipasok pengguna sebelum mengirimkannya ke laman dengan izin eksekusi SSI.
- Gunakan SUExec agar halaman dijalankan sebagai pemilik file, bukan pengguna server web.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference></reference>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Fiksasi Sesi</alert>
	<desc>Sidang Fiksasi adalah teknik serangan yang memaksa ID pengguna sesi untuk nilai eksplisit. Bergantung pada fungsionalitas situs web target, sejumlah teknik dapat digunakan untuk "memperbaiki" nilai ID sesi. Teknik ini berkisar dari eksploitasi Lintas-situs Scripting untuk membumbui situs web dengan permintaan HTTP yang sebelumnya dibuat. Setelah ID sesi pengguna telah diperbaiki, penyerang akan menunggu pengguna tersebut masuk. Begitu pengguna melakukannya, penyerang menggunakan nilai ID sesi yang telah ditentukan untuk mengambil identitas online yang sama.

Secara umum ada dua jenis sistem manajemen sesi ketika menyangkut nilai ID. The first type is "permissive" systems that allow web browsers to specify any ID. Tipe kedua adalah sistem "ketat" yang hanya menerima nilai sisi server. Dengan sistem permisif, ID sesi sewenang-wenang dipertahankan tanpa kontak dengan situs web. Sistem yang ketat mengharuskan penyerang untuk mempertahankan "sesi perangkap", dengan kontak situs berkala, mencegah waktuhabis tidak aktif.

Tanpa perlindungan aktif terhadap Session Fixation, serangan tersebut dapat dipasang di situs web manapun yang menggunakan sesi untuk mengidentifikasi pengguna yang diautentikasi. Situs web yang menggunakan ID sesi biasanya berbasis cookie, namun juga kolom sumber dan kolom tersembunyi juga digunakan. Sayangnya, sesi berbasis cookie adalah yang paling mudah diserang. Sebagian besar metode serangan yang diidentifikasi saat ini ditujukan untuk memperbaiki cookie.

Berbeda dengan mencuri ID sesi pengguna setelah mereka masuk ke situs web, Session Fixation menyediakan jendela peluang yang jauh lebih luas. Bagian aktif dari serangan terjadi sebelum pengguna masuk.</desc>
	<solution>Membatalkan setiap pengidentifikasi sesi yang ada sebelum otorisasi sesi pengguna baru

Untuk platform seperti ASP yang tidak menghasilkan nilai-nilai baru untuk sesi cookie, menggunakan cookie sekunder. Dalam pendekatan ini, menetapkan cookie sekunder pada browser pengguna ke nilai acak dan menetapkan variabel sesi ke nilai yang sama. Jika variabel sesi dan nilai cookie tidak cocok, membatalkan sesi, dan memaksa pengguna untuk masuk lagi.</solution>
	<reference>http://projects.webappsec.org/Sesi-Fiksasi</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>Penyalahgunaan URL redirector</alert>
	<desc>Pengalihan URL mewakili fungsi umum yang digunakan oleh situs web untuk meneruskan permintaan masuk ke sumber alternatif. Hal ini dapat dilakukan untuk berbagai alasan dan sering dilakukan untuk memungkinkan sumber daya dipindahkan dalam struktur direktori dan untuk menghindari pemutusan fungsi bagi pengguna yang meminta sumber daya di lokasi sebelumnya. Redirectors URL juga dapat digunakan untuk menerapkan penyeimbangan beban, memanfaatkan URL yang disingkat atau merekam tautan keluar. Ini adalah implementasi terakhir yang sering digunakan dalam serangan peretas seperti yang dijelaskan pada contoh di bawah ini. Redirectors URL tidak selalu mewakili kerentanan keamanan langsung namun dapat disalahgunakan oleh penyerang yang mencoba korban rekayasa sosial untuk percaya bahwa mereka menavigasi ke situs selain tujuan sebenarnya.</desc>
	<solution>Asumsikan semua masukan itu berbahaya Gunakan strategi validasi masukan "accept known good", i.e., menggunakan daftar putih masukan yang dapat diterima yang sesuai dengan spesifikasi. Tolak masukan apa pun yang tidak sesuai dengan spesifikasi, atau ubah menjadi sesuatu yang tidak. Jangan mengandalkan secara eksklusif untuk mencari masukan jahat atau cacat (i.e., jangan mengandalkan daftar hitam). Namun, blacklist dapat berguna untuk mendeteksi potensi serangan atau menentukan input mana yang salah sehingga harus ditolak secara langsung.

Saat melakukan validasi masukan, pertimbangkan semua properti yang berpotensi relevan, termasuk panjang, jenis masukan, kisaran nilai yang dapat diterima, input yang hilang atau tambahan, sintaksis, konsistensi di bidang terkait, dan kesesuaian dengan peraturan bisnis. Sebagai contoh logika aturan bisnis, "kapal" mungkin sintaksis karena hanya berisi karakter alfanumerik, namun tidak berlaku jika Anda mengharapkan warna seperti "merah" atau "biru".

Gunakan daftar putih URL atau domain yang disetujui yang akan digunakan untuk pengalihan.

Gunakan halaman penafian perantara yang memberi pengguna peringatan yang jelas bahwa mereka meninggalkan situs Anda. Terapkan batas waktu yang lama sebelum pengalihan terjadi, atau paksa pengguna untuk mengklik link tersebut. Hati-hati untuk menghindari masalah XSS saat membuat halaman penolakan.

Bila kumpulan objek yang dapat diterima, seperti nama file atau URLs, terbatas atau diketahui, buat pemetaan dari seperangkat nilai masukan tetap (seperti ID numerik) ke nama file atau URL yang sebenarnya, dan tolak semua masukan lainnya.

Misalnya, ID 1 dapat memetakan ke "/login.asp" dan ID 2 dapat memetakan ke "http://www.example.com/". Fitur seperti ESAPI AccessReferenceMap memberikan kemampuan ini.

Pahami semua area potensial dimana masukan yang tidak dipercaya dapat masuk ke perangkat lunak Anda: parameter atau argumen, cookies, apapun yang dibaca dari jaringan, variabel lingkungan, pencarian reverse DNS, hasil query, header permintaan, komponen URL, e-mail, file, database, dan setiap sistem eksternal yang menyediakan data ke aplikasi. Ingat bahwa masukan semacam itu dapat diperoleh secara tidak langsung melalui panggilan API.

Banyak masalah pengalihan terbuka terjadi karena pemrogram menganggap bahwa input tertentu tidak dapat dimodifikasi, seperti sampah dan bentuk lapangan tersembunyi.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>XPath Injeksi</alert>
	<desc>XPath Injection adalah teknik serangan yang digunakan untuk mengeksploitasi aplikasi yang membuat pertanyaan XPath (XML Jalan Bahasa) dari input yang diberikan pengguna ke pertanyaan atau menavigasi dokumen XML. Ini dapat digunakan secara langsung oleh aplikasi untuk pertanyaan dokumen XML, sebagai bagian dari operasi yang lebih besar seperti menerapkan transformasi XSLT ke dokumen XML, atau menerapkan XQuery ke dokumen XML. Sintaks XPath memiliki beberapa kemiripan dengan query SQL, dan memang, adalah mungkin untuk membentuk query seperti SQL pada dokumen XML menggunakan XPath.

Jika sebuah aplikasi menggunakan konstruksi query XPath run-time, memasukkan masukan pengguna yang tidak aman ke dalam kueri, memungkinkan penyerang untuk menyuntikkan data ke dalam kueri sehingga kueri yang baru terbentuk akan diuraikan dengan cara yang berbeda dari maksud pemrogram.</desc>
	<solution>Gunakan query XPath parameterized (misalnya dengan menggunakan XQuery). Ini akan membantu memastikan pemisahan antara bidang data plane dan control plane.

Validasi dengan benar masukan pengguna. Tolak data yang sesuai, saring bila sesuai dan lepaskan bila sesuai. Pastikan masukan yang akan digunakan dalam query XPath aman dalam konteks itu.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>Validitas Proses tidak mencukupi</alert>
	<desc>Proses yang tidak memadai Validasi terjadi saat aplikasi web gagal mencegah penyerang untuk menghindari aliran yang dimaksud atau logika bisnis aplikasi. Bila dilihat di dunia nyata, validasi proses yang tidak mencukupi telah mengakibatkan kontrol akses dan kerugian moneter yang tidak efektif.

Ada dua jenis proses utama yang memerlukan validasi: flow control dan logika bisnis.

"Flow control" mengacu pada proses multi langkah yang mengharuskan setiap langkah dilakukan dalam urutan tertentu oleh pengguna. Bila penyerang melakukan langkah yang salah atau tidak sesuai, kontrol akses mungkin dilewati dan kesalahan integritas aplikasi mungkin terjadi. Contoh proses multi langkah termasuk transfer kawat, pemulihan kata sandi, checkout pembelian, dan pendaftaran akun.

"Logika bisnis" mengacu pada konteks di mana proses akan dijalankan sesuai dengan kebutuhan bisnis. Memanfaatkan kelemahan logika bisnis membutuhkan pengetahuan bisnis; Jika tidak ada pengetahuan yang dibutuhkan untuk memanfaatkannya, kemungkinan besar itu bukan kesalahan logika bisnis. Karena ini, tindakan pengamanan khas seperti pemindaian dan pengkajian kode tidak akan menemukan kelas kelemahan ini. Salah satu pendekatan pengujian ditawarkan oleh OWASP dalam Panduan Pengujian mereka.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference></reference>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Attribute Blowup</alert>
	<desc>XML Attribute Blowup is a denial of service attack against XML parsers. Penyerang menyediakan dokumen XML yang berbahaya, yang merupakan proses parser XML yang rentan dengan cara yang sangat tidak efisien, yang menyebabkan beban CPU berlebihan. Inti dari serangan tersebut adalah memasukkan banyak atribut dalam simpul XML yang sama. Parser XML yang Rentan mengelola atribut dengan cara yang tidak efisien (misalnya dalam wadah data dimana penyisipan atribut baru memiliki O (n) runtime), menghasilkan non-linear (dalam contoh ini, kuadrat, yaitu O (n2)) runtime secara keseluruhan, yang menyebabkan terjadinya penyangkalan terhadap kondisi layanan melalui kelelahan CPU.</desc>
	<solution>Merancang mekanisme throttling ke dalam arsitektur sistem. Perlindungan terbaik adalah membatasi jumlah sumber daya yang mungkin menyebabkan pengguna yang tidak sah dikeluarkan. Model otentikasi dan kontrol akses yang kuat akan membantu mencegah serangan semacam itu terjadi. Aplikasi masuk harus dilindungi terhadap serangan DoS sebanyak mungkin. Membatasi akses database, mungkin dengan hasil set menyembunyikan, dapat membantu meminimalkan sumber daya yang dikeluarkan. Untuk lebih membatasi potensi serangan DoS, pertimbangkan untuk melacak tingkat permintaan yang diterima dari pengguna dan memblokir permintaan yang melebihi ambang batas tingkat yang ditetapkan.

Mitigasi serangan kelelahan sumber daya mengharuskan sistem target:
  * Mengetahui serangan tersebut dan menolak akses pengguna lebih jauh untuk jangka waktu tertentu, atau
  * Mencoreng semua permintaan secara merata agar lebih sulit untuk mengkonsumsi sumber daya lebih cepat daripada yang bisa mereka bebaskan lagi. 

Solusi pertama adalah masalah tersendiri, karena memungkinkan penyerang untuk mencegah penggunaan sistem oleh pengguna tertentu yang sah. Jika penyerang meniru identitas pengguna yang valid, dia mungkin bisa mencegah pengguna mengakses server yang bersangkutan.

Solusi kedua hanya sulit untuk dilembagakan secara efektif -- dan bahkan jika dilakukan dengan benar, solusi ini tidak memberikan solusi penuh. Itu hanya membuat serangan membutuhkan lebih banyak sumber daya dari pihak penyerang.

Pastikan bahwa protokol memiliki batas skala tertentu yang ditempatkan pada mereka.

Pastikan semua kegagalan dalam alokasi sumber daya menempatkan sistem ke dalam postur tubuh yang aman.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>Penyalahgunaan Fungsi</alert>
	<desc>Penyalahgunaan Fungsi adalah teknik serangan yang menggunakan fitur dan fungsi situs web untuk menyerang dirinya sendiri atau orang lain. Penyalahgunaan Fungsi dapat digambarkan sebagai penyalahgunaan fungsi yang dimaksudkan oleh aplikasi untuk melakukan hasil yang tidak diinginkan. Serangan ini memiliki beragam hasil seperti mengkonsumsi sumber daya, menghindari akses kontrol, atau bocornya informasi. Potensi dan tingkat penyalahgunaan akan bervariasi dari situs web ke situs web dan aplikasi ke aplikasi. Penyalahgunaan serangan fungsi sering merupakan kombinasi dari jenis serangan lainnya dan / atau memanfaatkan vektor serangan lainnya.</desc>
	<solution>Selalu gunakan API dengan cara yang ditentukan.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>Entitas Eksternal XML</alert>
	<desc>Teknik ini memanfaatkan fitur XML untuk membangun dokumen secara dinamis pada saat pemrosesan. Pesan XML dapat memberikan data secara eksplisit atau dengan menunjuk ke URI dimana data ada. Dalam teknik penyerangan, entitas eksternal bisa menganti nilai entitas dengan data berbahaya, rujukan alternatif atau mungkin membahayakan keamanan dari data server/XML aplikasi memiliki akses untuk.
	Penyerang mungkin juga menggunakan entitas eksternal agar mendownload server layanan web kode berbahaya atau konten ke server untuk digunakan dalam sekunder atau ikut pada serangan.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference></reference>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>Ekspansi Entitas XML</alert>
	<desc>Serangan perluasan Entitas XML, memanfaatkan kemampuan dalam DTD XML yang memungkinkan pembuatan makro khusus, yang disebut entitas, yang dapat digunakan di seluruh dokumen. Dengan mendefenisikan secara rekursif satu set pada entitas kustom pada bagian atas sebuah dokumen, penyerang bisa membanjiri parser yang mencoba untuk sepenuhnya menyelesaikan entitas dengan memaksa mereka untuk iterate hampir tanpa batas waktu pada defenisi rekursif ini.

Pesan berbahaya XML digunakan untuk memaksa ekspansi entitas rekursif (atau proses pengulangan lainnya) itu sepenuhnya menggunakan sumber daya server yang tersedia.</desc>
	<solution>Jika mungkin, melarang penggunaan DTDs atau menggunakan parser XML yang membatasi ekspansi dari entitas rekursif DTD.

Sebelum mengurai file XML dengan DTDs terkait, pindai deklarasi entitas rekursif dan jangan terus kan menguraikan konten yang berpotensi meledak.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Sidik jari</alert>
	<desc>Metodologi yang paling umum untuk penyerang adalah untuk mencetak tapak pertama targetnya kehadiran web dan menghitung sebanyak mungkin informasi. Dengan informasi ini, penyerang bisa mengembangkan sebuah skenario serangan akurat, yang secara efektif akan mengeksploitasi kerentanan dalam jenis/versi perangkat lunak yang digunakan oleh host target.

Sidik jari multi-tier mirip dengan pendahulunya, TCP / IP Sidik jari (dengan pemindai seperti Nmap) kecuali difokuskan pada Lapisan Aplikasi dari model OSI dan bukan Transport Layer. Teori dibalik sidik jari ini adalah untuk membuat profil platform target yang akurat pada, teknologi perangkat lunak aplikasi web, versi database backend, konfigurasi dan bahkan mungkin arsitektur/topologi jaringan mereka.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference></reference>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>Injeksi XQuery</alert>
	<desc>XQuery Injection adalah varian dari serangan injeksi SQL klasik terhadap bahasa XML XQuery. Injeksi XQuery menggunakan data yang divalidasi dengan tidak benar yang dilewatkan ke perintah XQuery. Inturn ini akan mengeksekusi perintah atas nama penyerang yang miliki rutinitas XQuery. Injeksi XQuery dapat digunakan untuk menghitung elemen di lingkungan korban, memasukkan perintah ke host lokal, atau mengeksekusi query ke file jarak jauh dan sumber data. Seperti serangan injeksi SQL, terowongan penyerang melalui jalur masuk aplikasi untuk menargetkan lapisan akses sumber daya.</desc>
	<solution>Gunakan kueri parameter. Ini akan membantu memastikan pemisahan antara data pesawat dan kontrol pesawat.

Benar memvalidasi masukan pengguna. Menolak data yang sesuai, menyaring yang sesuai dan melepaskan ditempat yang sesuai. Pastikan masukan yang akan digunakan dalam query XQL aman dalam konteks itu.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Kadaluarsa Sesi Tidak Cukup</alert>
	<desc>Kurangnya Sesi Kadaluarsa terjadi saat aplikasi Web mengizinkan penyerang untuk menggunakan kembali kredensial sesi lama atau ID sesi untuk otorisasi. Kurangnya Sesi Kadaluarsa akan meningkatkan eksposur situs Web terhadap serangan yang mencuri atau menggunakan kembali pengenal sesi pengguna.

Karena HTTP adalah protokol tanpa kewarganegaraan, situs Web biasanya menggunakan cookies untuk menyimpan ID sesi yang secara unik mengidentifikasi pengguna dari permintaan yang diminta. Akibatnya, kerahasiaan masing-masing ID sesi harus dijaga agar tidak banyak pengguna mengakses akun yang sama. Sesi ID yang dicuri dapat digunakan untuk melihat akun pengguna lain atau melakukan transaksi yang tidak benar.

Kedatangan sesi terdiri dari dua tipe timeout: tidak aktif dan absolut. Jangka waktu absolut didefinisikan oleh jumlah total waktu sesi dapat valid tanpa autentikasi ulang dan batas waktu tidak aktif adalah jumlah waktu jeda yang diizinkan sebelum sesi tersebut tidak berlaku lagi. Kurangnya kadaluwarsa sesi yang tepat dapat meningkatkan kemungkinan keberhasilan serangan tertentu. Waktu kadaluarsa yang panjang akan meningkatkan kesempatan penyerang untuk berhasil menebak ID sesi yang valid. Semakin lama waktu kadaluarsa, sesi terbuka yang lebih bersamaan akan ada pada waktu tertentu. Semakin besar kolam sesi, semakin besar kemungkinan penyerang menebaknya secara acak. Meskipun batas waktu durasi sesi pendek tidak membantu jika token segera digunakan, batas waktu singkat membantu memastikan bahwa token lebih sulit ditangkap saat masih valid.

Aplikasi Web harus membatalkan sesi setelah waktu siaga yang telah ditentukan telah berlalu (batas waktu) dan memberi pengguna sarana untuk membatalkan sesi mereka sendiri, yaitu logout; ini membantu menjaga jangka waktu ID sesi sesingkat mungkin dan diperlukan di lingkungan komputasi bersama di mana lebih dari satu orang memiliki akses fisik yang tidak terbatas ke komputer. Fungsi keluar harus terlihat jelas oleh pengguna, secara eksplisit membatalkan sesi pengguna dan melarang penggunaan kembali sesi token.</desc>
	<solution>Tetapkan tanggal kadaluarsa / kredensial.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Pengindeksan tidak aman</alert>
	<desc>Pengindeksan tidak aman merupakan ancaman terhadap kerahasiaan data situs web. Pengindeksan konten situs web melalui proses yang memiliki akses ke file yang seharusnya tidak dapat diakses publik berpotensi membocorkan informasi tentang keberadaan file tersebut, dan tentang isinya. Dalam proses pengindeksan, informasi tersebut dikumpulkan dan disimpan oleh proses pengindeksan, yang kemudian dapat diambil (walaupun tidak sepele) oleh penyerang yang ditentukan, biasanya melalui serangkaian pertanyaan ke mesin pencari. Penyerang tidak menggagalkan model keamanan mesin pencari. Dengan demikian, serangan ini halus dan sangat sulit untuk dideteksi dan digagalkan - tidak mudah untuk membedakan permintaan penyerang dari kueri pengguna yang sah.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference></reference>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Pemulihan Sandi tidak cukup</alert>
	<desc>Pemulihan Password yang tidak memadai adalah ketika sebuah situs web mengizinkan penyerang untuk secara tidak sah mendapatkan, mengubah atau memulihkan kata sandi pengguna lain. Metode otentikasi situs web konvensional mengharuskan pengguna untuk memilih dan mengingat kata sandi atau frasa sandi. Pengguna harus menjadi satu-satunya orang yang mengetahui password dan harus diingat secara tepat. Seiring berjalannya waktu, kemampuan pengguna mengingat kata kunci memudar. Masalahnya semakin rumit ketika pengguna rata-rata mengunjungi 20 situs yang mengharuskan mereka memberikan kata sandi.  (Surve RSA: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Dengan demikian, pemulihan password merupakan bagian penting dalam melayani pengguna online.

Contoh proses pemulihan kata sandi otomatis termasuk mengharuskan pengguna menjawab "pertanyaan rahasia" yang didefinisikan sebagai bagian dari proses pendaftaran pengguna. Pertanyaan ini dapat dipilih dari daftar pertanyaan kaleng atau yang disediakan oleh pengguna. Mekanisme lain yang digunakan adalah meminta pengguna memberikan "petunjuk" saat pendaftaran yang akan membantu pengguna mengingat kata sandinya. Mekanisme lain mengharuskan pengguna untuk menyediakan beberapa lembar data pribadi seperti nomor jaminan sosial, alamat rumah, kode pos, dll. untuk memvalidasi identitas mereka. Setelah pengguna membuktikan siapa mereka, sistem pemulihan akan menampilkan atau mengirimi mereka sandi baru.

Situs web dianggap memiliki Pemulihan Sandi yang tidak memadai saat penyerang dapat menggagalkan mekanisme pemulihan yang digunakan. Hal ini terjadi ketika informasi yang diperlukan untuk memvalidasi identitas pengguna untuk pemulihan mudah ditebak atau dapat dielakkan. Sistem pemulihan password dapat dikompromikan melalui penggunaan serangan brute force, kelemahan sistem yang melekat, atau pertanyaan rahasia yang mudah ditebak.</desc>
	<solution>Pastikan semua masukan yang diberikan oleh pengguna ke mekanisme pemulihan kata sandi disaring dan divalidasi secara menyeluruh

Jangan gunakan pertanyaan keamanan lemah standar dan gunakan beberapa pertanyaan keamanan.

Pastikan bahwa ada pelambatan jumlah jawaban yang salah atas pertanyaan keamanan. Nonaktifkan fungsi pemulihan kata sandi setelah sejumlah (kecil) tebakan salah.

Perlu agar pengguna benar menjawab pertanyaan keamanan sebelum menyetel ulang kata sandinya dan mengirim kata sandi baru ke alamat e-mail catatan.

Jangan pernah mengizinkan pengguna untuk mengontrol alamat email yang akan dikirim kata sandi baru ke dalam mekanisme pemulihan kata sandi.

Tetapkan kata sandi sementara baru daripada mengungkapkan kata kunci asli.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>